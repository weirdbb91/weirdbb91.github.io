---
header:
  teaser            : # 썸네일 이미지 /assets/images/face_army.jpg
title               : GoF # 제목
excerpt             : 한권 요약 # 썸네일 한줄 요약
last_modified_at    : 2020-12-06 # 마지막 수정일
categories          : DesignPattern GoF
tags                : DesignPattern GoF
toc                 : # 목차 사용여부
toc_label           : # 목차 제목
# {: .notice--info}
---
이 글은 아래의 출처에서 내용을 참고하여 작성하였습니다.  
출처 : [https://yrok.tistory.com/](https://yrok.tistory.com/)
[https://en.wikipedia.org/wiki/Design_Patterns#cite_note-1](https://en.wikipedia.org/wiki/Design_Patterns#cite_note-1)


---
---
[머리말]

이 책은 객체지향적 기술이나 설계를 소개하는 책이 아닙니다. 이 책은 독자들이 최소한 한 가지 객체지향 프로그램 언어에 대한 사전 지식과 경험이 있으며, 또 객체지향 설계에 대한 경험도 있다고 전제합니다. 이책은 객체지향 소프트웨어를 설계할 때 겪는 특별한 문제에 대한 간결하고 명확한 해결책을 서술한 디자인패턴 책입니다. 자신의 설계를 더 융통성 있고, 모듈화되며, 재사용 가능하고, 이해하기 쉬운 것으로 만들 수 있는 통찰력을 지니게 될 겁니다. 계속 반복해서 책을 읽다 보면 설계의 통찰력과 영감을 얻을 수 있습니다.

 

[독자를 위한 가이드]

첫 번째 부분에서는(1장과 2장) 디자인 패턴이 무엇인지와 디자인 패턴이 어떻게 객체 지향 소프트웨어 설계에 도움을 주는 지 설명합니다. 두 번째 부분은(3~5장) 목록, 즉 카탈로그로 정리된 실제 디자인 패턴 23개에 대한 설명입니다. 카탈로그는 세 가지 종료(생성, 구조, 행동)의 대분류 아래에 23개의 패턴이 나뉜 형태로 구성되어 있습니다.

패턴들 간의 참조 관계를 이용할 수 있습니다. 즉, 패턴마다 관련된 패턴을 정의하는데, 이 관련된 패턴을 이용해서 카탈로그를 파악할 수 있습니다. 패턴 카탈로그를 읽는 또 다른 방법은 문제를 중심으로 패턴에 접근하는 것입니다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-머리말 [IT 고인물]

---
---

[1.3 디자인 패턴 기술하기]

설계를 재사용하기 좋게 만들려면 설계를 하기까지의 다양한 결정, 대안, 장단점 등을 고려한 과정도 함께 적어주어야 합니다.

-패턴 이름과 분류(Pattern Name and Classification)

-의도(Intent)

-다른 이름(Also Known As)

-동기(Motivation) : 설계 문제를 제시하고, 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해 주는 일종의 시나리오

-활용성(Applicability)

-구조(Structure) : 객체 모델링 기법(Object Modeling Technique: OMT)에 기반을 둔 표기법을 이용하여 해당 패턴에서 쓰는 클래스들을 시각적으로 나타냅니다. 또한, 객체 사이에 오가는 요청과 협력 관계의 순차를 표현하기 위해서 상호작용 다이어그램도 이용

-참여자(Participant) : 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명

-협력 방법(Collaboration) : 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의

-결과(Consequence) : 이 패턴을 이용한 결과는 무엇이고 장단점은?

-구현(Implementation) : 패턴을 구현할 때 주의해야 할 함정, 힌트, 기법은?

-예제 코드(Sample Code)

-잘 알려진 사용예(Known Use)

-관련 패턴(Related Pattern)

 

## [1.4 디자인 패턴 카탈로그]

-추상 팩토리(Abstraction Factory)

-적응자(Adapter)

-가교(Bridge)

-빌더(Builder)

-책임 연쇄(Chain of Responsibility)

-명령(Command)

-복합체(Composite)

-장식자(Decorator)

-퍼사드(Facade)

-팩토리 메서드(Factory Method)

-플라이급(Flyweight)

-해석자(Interpreter)

-반복자(Iterator)

-중재자(Mediator)

-메멘토(Memento)

-감시자(Observer)

-원형(Prototype)

-프록시(Proxy)

-단일체(Singleton)

-상태(State)

-전략(Strategy)

-템플릿 메서드(Template Method)

-방문자(Visitor)



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론1314?category=828277 [IT 고인물]

---
---

[1.5 카탈로그 조직화하기]

패턴을 분류하는 기준은 두 가지입니다. 첫 번째 분류 기준은 목적. 패턴은 생성, 구조, 행동 중의 한 가지 목적을 갖습니다. 생성 패턴은 객체의 생성 과정에 관여하는 것이고, 구조 패턴은 클래스나 객체의 합성에 관한 패턴들입니다. 행동 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의합니다.

두 번째 분류 기준은 범위. 패턴을 주로 클래스에 적용하는지 아니면 객체에 적용하는지를 구분하는 것입니다. 클래스 패턴은 클래스와 서브클래스 간의 관련성을 다루는 패턴입니다. 관련성은 주로 상속이며, 컴파일 타임에 정적으로 결정됩니다. 객체 패턴은 객체 관련성을 다루는 패턴으로서, 런타임에 변경할 수 있으며 더 동적인 성격을 가집니다. 대부분의 패턴들은 어느 정도 상속을 이용합니다.

생성(Creational) “클래스” 패턴은 객체를 생성하는 책임의 일부를 서브클래스가 담당하도록 넘깁니다. 그러나 생성 “객체” 패턴은 이를 다른 깨체에게 위임합니다.

구조(Structural) “클래스” 패턴은 상속을 이용해서 클래스를 복합하고, 구조 “객체” 패턴은 깨체를 합성하는 방법을 정의합니다.

행동(Behavioral) “클래스” 패턴은 상속을 이용해서 알고리즘과 제어 흐름을 기술하고, 행동 “객체” 패턴은 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술합니다.

패턴을 조직하는 또 다른 방법으로는, 일부 패턴은 함께 사용해야 할 때가 있거나 대안이 될 때도 있음.

또 다른 방법으로는 패턴 간의 참조 관계에 따라 관리하는 것. “디자인 패턴 관계도”는 패턴마다 기술한 “관련 패턴”의 참조 관계

 

[1.6 디자인 패턴을 이용하여 문제를 푸는 방법]

[적당한 객체 찾기]

객체지향 프로그램은 객체(Object)로 만듭니다. 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(Procedure)를 함께 묶은 단위입니다. 프로시저를 일반적으로 메서드(Method) 또는 연산(Operation)이라고 합니다. 객체는 요청(Request) 또는 메시지(Message)를 사용자에게 받으면 연산을 수행합니다.

요청은 객체에 연산을 실행하게 하는 유일한 방법이고, 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법입니다. 이러한 접근의 제약 사항으로 객체의 내부 상태는 캡슐화(Encapsulate)된다고 말합니다. 객체 외부에서는 객체의 내부 데이터에 직접 접근할 수 없고, 객체의 내부 데이터 표현 방법(데이터 타입 등)을 알 수 없습니다.

객체지향 설계의 가장 어려운 부분은 시스템을 구성할 객체의 분할을 결정하는 것입니다. 고려해야 할 요인에는 캡슐화, 크기 정하기, 종속성, 유연성, 성능, 진화, 재사용성 등이 있습니다. 이 문제에 대해 객체지향 설계 방법론들은 서로 다른 방법으로 접근합니다. 문제 기술서를 작성하고 명사와 동사를 추출해서 각각을 클래스와 연산으로 만드는 방법. 시스템의 협력 관계나 책임성을 중심으로 설계하는 방법, 실세계를 모델로 만들고 이를 분석해 설계로 전이하는 과정에서 객체로 바꾸는 방법.

객체지향 설계는 실세계와 대응 관계를 갖지 못할 때가 많습니다. 즉, 분석 모델의 객체는 실세계 객체들이지만, 설계 모델의 객체에는 배열, 리스트처럼 구현에 가까운 클래스들도 있습니다. 실세계를 그대로 반영하는 모델링만 강조하면 현재의 실세계는 반영할 수 있지만 미래의 실세계는 반영할 수 없습니다. 설계 단계 동안 만들어야 하는 새로운 추상화는 설계의 유연성을 증진하기 위한 중요한 노력 중 하나입니다.

디자인 패턴은 여러분이 덜 명확한 추상적 개념과 이것을 잡아낸 객체를 알아보는 데에 도움을 줍니다. 전략 패턴은 상호교환이 가능한 알고리즘군을 어떻게 구현할지를 설명합니다. 상태 패턴은 대상들의 각 상태를 객체로 표현합니다.

 

[객체의 크기 결정]

디자인 패턴에서 이 문제의 답을 얻을 수 있다. 퍼사드 패턴은 서브시스템을 어떻게 객체로 표현할 수 있는지 설명하고, 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 방법을 설명한다. 추상팩토리 패턴과 빌더 패턴은 다른 객체를 생성하는 책임만 있는 객체를 만들어 낸다. 방문자 패턴과 명령 패턴은 요청을 자신이 처리하는 것이 아니라, 다른 객체나 객체 집합이 요청을 처리하여 구현하도록 책임지는 객체를 만들어 낸다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론1516?category=828277 [IT 고인물]

---
---

[객체 인터페이스의 명세]

객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환 값을 명세한다. 이를 연산의 시그니처(signature)라고 한다. 인터페이스(interface)는 객체가 정의하는 연산의 모든 시그니처들을 일컫는 말로 객체의 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합이다.

타입(type)은 특정 인터페이스를 나타낼 때 사용하는 이름. 다른 인터페이스를 포함하는 인터페이스를 서브타입(subtype), 다른 인터페이스가 포함하는 인터페이스를 슈퍼타입(supertype). 서브타입은 슈퍼타입의 인터페이스를 상속한다. 서브타입이 슈퍼타입을 상속하면, 서브타입은 슈퍼타입에 정의된 연산을 포함하게 된다.

인터페이스 개념은 객체지향 시스템에서 가장 기본적인 것이다. 객체는 인터페이스로 자신을 드러낸다. 외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없기 때문에 인터페이스를 통해서만 처리를 요청할 수 있다. 어떤 요청과 그 요청을 처리할 객체를 프로그램 실행 중, 즉 런타임에 연결 짓는 것을 동적 바인딩(dynamic binding)이라고 한다.

동적 바인딩은 프로그램이 기대한느 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있게 해준다. 이런 대체성을 우리는 다형성(polymorphism)이라고 하는데, 이는 객체 지향 시스템의 핵심 개념이다.

디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와준다. 메멘토 패턴은 객체의 내부 상태를 어떻게 저장하고 캡슐화해야 하는지를 정의함으로써 객체가 나중에 그 상태로 복구할 수 있는 방법을 알려준다.

디자인 패턴은 인터페이스 간의 관련성도 정의한다. 예를 들어, 장식자 패턴과 프록시 패턴은 장식되고 중재되는 객체와 동일한 인터페이스를 갖도록 장식자 객체와 프록시 객체의 인터페이스를 요청한다. 방문자 패턴에서 방문자 인터페이스는 방문자 객체가 방문하는 객체들의 클래스 인터페이스를 그 방문자 인터페이스에 모두 반영하도록 한다.

 

[객체 구현 명세하기]

객체의 구현은 클래스(class)에서 정의(define)한다. 클래스는 객체의 내부 데이터와 표현 방법을 명세하고, 그 객체가 수행할 연산을 정의한다. 객체는 클래스를 인스턴스로 만듦으로써 생성된다. 즉, 객체는 클래스의 인스턴스이다. 클래스의 인스턴스화 과정은 객체의 내부 데이터(인스턴스 변수, instance variable)에 대한 공간을 할당하고, 이 데이터들을 연산과 관련짓는 것이다.

서브 클래스(subclass)가 부모 클래스(parent class)를 상속하면, 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스가 갖게 된다.

추상 클래스(abstract class)는 모든 서브클래스 사이의 공통되는 인터페이스를 정의한다. 추상 클래스는 정의한 모든 연산이나 일부 연산의 구현을 서브 클래스에게 넘긴다. 추상 클래스는 정의한 모든 연산이나 일부 연산의 구현을 서브 클래스에게 넘긴다. 추상 클래스는 인스턴스를 생성할 수 없다. 정의만 하고 구현하지 않는 연산을 추상 연산(abstract operation)이라 하고, 추상 클래스가 아닌 클래스를 구체 클래스(concrete class)라고 한다.

서브 클래스는 부모 클래스가 정의한 행동을 재정의하거나 정제할 수 있다. 즉, 오버라이드(override)로 서브 클래스는 부모 클래스에 정의된 처리 방식을 변경할 수 있다.

믹스인 클래스(mixin class)는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스이다. 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷하다. 다중 상속이 필요하다.

 

[클래스 상속 대 인터페이스 상속]

클래스는 객체의 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의한다. 반면, 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의한다. 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있다. 즉, 객체의 구현은 다를지라도 인터페이스는 같을 수 있다는 의미이다. C++ 같은 언어에서 클래스는 객체 타입과 구현 모두를 의미한다.

클래스 상속은 객체의 구현을 정의할 때 이미 정의된 객체의 구현을 바탕으로 한다. 인터페이스 상속(서브타이핑)은 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하는 메커니즘이다. C++ 언어에서 상속은 인터페이스와 구현 상속 모두를 의미한다. C++에서 인터페이스를 상속하는 표준적인 방법은 (순수) 가상 함수를 갖는 클래스를 public으로 상속하는 것이다. public으로 상속되면 서브클래스도 부모 클래스가 갖는 가상 함수를 상속받고 서브클래스가 구현을 담당하며, 상속받은 인터페이스가 서브클래스의 사용자에게도 공개된다. C++에서 순수한 인터페이스 상속은 순수 가상 함수를 정의한 추상 클래스를 public으로 상속하면 비슷하게 구현할 수 있다. 순수 가상 함수는 전혀 구현을 정의할 수 없는 함수이기 때문에 이를 상속한다는 것은 진정한 의미의 인터페이스만을 상속받는다는 뜻이다. private로 상속하면 부모 클래스에 정의된 연산은 서브클래스의 사용자에게는 공개되지 않기 때문에 상속의 목적은 인터페이스 확장이 아닌 부모 클래스 구현의 재사용이다.

C++ 프로그래머들은 구체적인 클래스를 정의하고 요청을 보내기보다 추상 클래스의 객체에게 메시지를 보내도록 프로그래밍한다. 이렇게 하면 런타임에 구체 클래스의 인스턴스로 바꿀 수 있다. 즉, 추상 클래스를 상속한다는 것은 단순한 코드의 재사용을 위한 상속이 아니라 추상 클래스가 정의하는 인터페이스를 상속하겠다는 의미이다. 첵임 연쇄 패턴에 나오는 객체들은 반드시 동일한 타입을 가져야 하지만, 이들이 구현을 공유할 부분은 없다. 복합체 패턴에서 Component 클래스는 공통의 인터페이스를 정의하고, Composite 클래스는 공통의 구현을 정의한다. 명령, 감시자, 상태, 전략 패턴은 순수 인터페이스인 추상 클래스를 써서 구현될 때가 많다.

 

[구현에 따르지 않고, 인터페이스에 따르는 프로그래밍]

클래스 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메커니즘이다. 그러나 구현의 재사용이 전부는 아니다. 상속이 가진 다른 기능들 중에는 동일한 인터페이스를 갖는 객체군을 정의하는 것이 있다. 객체군을 정의하는 것이 중요한 이유는 다형성을 끌어낼 수 있기 때문이다. 상속을 적절하게 이용하면, 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 된다. 모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있다. 이로써 모든 서브클래스들은 부모 클래스의 서브 타입이 되는 것이다.

추상 클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻을 수 있는 두가지 이점.

1.사용자가 원하는 인터페이스를 그 객체가 만족하고 있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없다.

2.사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 된다.

이렇게 하면 서브시스템 간의 구현 종속성이 없어진다.

즉, 구현이 아닌 인터페이스에 따라 프로그래밍해야 한다. 따라서 어떤 변수(객체)를 구체 클래스의 인스턴스로 선언하는 일은 피해야 한다. 대신 추상클래스의 인터페이스를 따르는 인스턴스 변수를 정의해야한다.

추상 팩토리, 빌더, 팩토리 메서드, 원형 패턴 및 단일체 패턴에서는 구체 클래스에서 인스턴스를 생성하도록 하고 있다. 이들 패턴에서는 객체 생성의 과정을 추상화함으로써 인스턴스화할 때 인터페이스와 구현을 연결하는 다른 방법을 제시한다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론16?category=828277 [IT 고인물]

---
---


[재사용을 실현 가능한 것으로]

[상속 대 합성]

객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성(object compostion)이다.

서브클래싱에 의한 재사용을 화이트박스 재사용(white-box reuse). 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스

객체 합성은 클래스 상속에 대한 대안이다. 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다. 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다. 블랙박스 재사용(black-box reuse). 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.

클래스 상속은 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다. 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 있는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.

클래스 상속의 단점.

1.런타임에 상속받은 부모 클래스의 구현을 변경할 수는 없다는 점이다.

2.부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는 점이다. 부모 클래스 구현에 변경이 생기면 서브클래스도 변경해야 한다.

이 구현의 종속성이 걸림돌로 작용하면서, 서브클래스를 재사용하려고 할 때 문제가 발생한다. 상속한 구현이 새로운 문제에 맞지 않을 때, 부모 클래스를 재작성해야 하거나 다른 것으로 대체하는 일이 생기게 된다. 해결하는 방법 한 가지는 추상 클래스에서만 상속받는 것이다. 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의한다.

객체 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의된다. 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에, 인터페이스 정의에 더 많은 주의를 기울여야 한다.

클래스 상속보다 객체 합성을 더 선호하는 이유는 각 클래스의 캡슐화를 유지할 수 있다. 객체 합성으로 설계되면 클래스의 수는 적어지고 객체의 수는 좀더 많아질 수 있지만, 시스템의 행동은 클래스에 정의된 정적인 내용보다는 런타임에 드러나는 객체 합성에 의한 상호 관련성에 따라 달라질 수 있다.

객체 합성이 클래스 합성보다 더 나은 방법!

상속에 의한 재사용은 기존 클래스들을 조합해서 새로운 구성요소를 쉽게 만들 수 있도록 해준다. 그러므로 상속과 객체 합성은 적절히 조합되어야 완벽한 재사용이 가능하다.

 

[위임(delegation)]

위임에서는 두 객체가 하나의 요청을 처리한다. 수신 객체가 연산의 처리를 위임자(delegate)에게 보낸다. C++에서는 this를 이용해서 수신 객체를 참조한다. 위임과 동일한 효과를 얻으려면 수신 객체는 대리자에게 자신을 매개변수로 전달해서 위임된 연산이 수신자를 참조하게 한다.

위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게 하고, 복합하는 방식도 변경해 준다는 것이다.

위임이 갖는 단점은, 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 ㅈ어적인 소프트웨어 구조보다 이해하기가 더 어렵다는 것이다. 이런 위임이 만들어 내는 복잡함보다 단순화의 효과를 더 크게 할 수 있다면 그 설계는 사용하기 좋은 설계이다.

상태, 전략 방문자 패턴에서 위임 방식을 사용한다. 상태 패턴에서 객체는 현재 상태를 표현하는 상태 객체에 요청의 처리를 위임한다. 전략 패턴에서 객체는 요청을 수행하는 추상화한 전략 객체에게 특정 요청을 위임한다. 이 두 패턴의 목적은 처리를 전달하는 객체를 변경하지 않고 객체의 행동을 변경할 수 있게 하자는 것이다. 방문자 패턴에서, 객체 구조의 각 요소에 수행하는 연산은 언제나 방문자 객체에게 위임된 연산이다.

위임에 전적으로 의존하는 패턴들. 중재자 패턴은 객체 간의 교류를 중재하는 객체를 도입하여 중재자 객체가 다른 객체로 연산을 전달하도록 구현한다. 책임 연쇄 패턴은 한 객체에서 다른 객체로 고리를 따라서 요청의 처리를 계속 위임한다. 가교 패턴은 구현과 추상적 개념을 분리하는 패턴이다. 추상화와 특정 구현을 대응시키고 추상화는 단순히 자신의 연산을 구현에 전달한다.

 

[상속 대 매개변수화된 타입(parameterized type)]

제네릭(generic), c++에서는 템플릿(template). 이 기법은 타입을 정의할 때 타입이 사용하는 다른 모든 타입을 다 지정하지 않은 채 정의한다. 미리 정의하지 않은 타입은 매개변수로 제공한다.

매개변수화된 타입은 객체지향 시스템에서 행동을 복합할 수 있는 세 번째 방법. 1. 클래스 상속, 2.객체 합성.

1.서브클래스에 의해 연산을 구현하는 방법(템플릿 메서드 패턴의 응용) : 상속

2.정렬 루틴으로 전달된 객체(전략) : 합성

3.C++ 템플릿이나, 제네릭으로 정의한 클래스의 인자로 원소를 비교할 함수 이름을 명시 : 매개변수화

객체 합성은 런타임에 행동을 변경할 수 있지만, 행동이 위임되기 때문에 비효율적일 수 있다. 상속이 연산에 대한 기본 행동을 부모 클래스가 제공하고 이를 서브클래스에서 재정의하도록 하는 것이라면, 매개변수화된 타입은 클래스가 사용하는 타입을 변경하게 하는 것이다. 상속도 매개변수화된 타입이라고 볼 수 있지만, 런타임에 변경이 일어나지는 않는다.

 

[런타임 및 컴파일 타임의 구조를 관계짓기]

객체 관계 중에는 집합(aggregation)과 인지(acquaintance)라는 것이 있다. 집합은 한 객체가 다른 객체를 소유하거나 그것에 책임을 진다는 뜻이다. 객체 통합에는 통합된 객체 및 그 객체를 소유한 객체의 생존주기가 똑같다는 의미도 들어 있다. 객체 인지는 한 객체가 다른 객체에 대해 알고 있음을 의미한다. 이를 “연관(association)” 관계 또는 “사용(using)” 관계라고도 한다. 인지를 받는 객체는 서로의 연산을 요청할 수도 있지만 서로에 대해 책임은 지지 않는다.

C++에서는 멤버 변수를 다른 객체의 인스턴스로 정의하여 집합 관계를 구현한다. 그러나 집합 관계를 표현하는 더 일반적인 방법은 다른 인스턴스를 가리키는 포인터를 정의하는 것이다. 인지 관계 역시 포인터로 구현한다. 인지 관계와 집합 관계는 언어의 처리 방식이 아닌 사용 목적에 따라 결정해야 한다. 집합 관계는 인지 관계보다는 강력한 영속성의 개념을 갖는다. 인지 관계는 자주 바뀌게 된다.

많은 디자인 패턴이 컴파일 시점과 런타임 구조를 명시적으로 구분하고 있다. 복합체 패턴과 장식자 패턴은 복잡한 실행 구조를 구축하는 데 유용한 패턴이다. 감시자 패턴으로 만드는 런타임 구조는 이 패턴을 잘 알고 있지 않는 한 이해하기가 종종 까다롭다. 책임 연쇄 패턴은 상속이 드러나지 않는 교류 패턴을 만들어 낸다.

 

[변화에 대비한 설계]

재사용을 최대화하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야 한다. 변화를 수용하지 못하는 설계는 앞으로 재설계가 필요하게 된다. 이런 변경들은 클래스의 재설계와 재구현, 사용자의 수정, 새로운 테스팅을 유발한다.

디자인 패턴을 써서 재설계를 할 수 밖에 없게 하는 이유와 해당 문제 해결에 사용하는 디자인 패턴

1.특정 클래스에서 객체 생성. 이를 방지하려면 객체를 직접 생성해서는 안된다.

디자인 패턴 : 추상 팩토리, 팩토리 메서드, 원형

2.특정 연산에 대한 의존성. 요청의 처리 방법을 직접 코딩하는 방식을 피한다.

디자인 패턴 : 책임 연쇄, 명령

3.하드웨어와 소프트웨어 플랫폼에 대한 의존성. 플랫폼 종속성을 제거한다.

디자인 패턴 : 추상 팩토리, 가교

4.객체의 표현이나 구현에 대한 의존성. 정보를 사용자에게 감춤

디자인 패턴 : 추상 팩토리, 가교, 메멘토, 프록시

5.알고리즘 의존성. 변경이 가능한 알고리즘은 분리해낸다.

디자인 패턴 : 빌더, 반복자, 전략, 템플릿 메서드, 방문자

6.높은 결합도. 추상 클래스 수준에서 결합도를 정의한다거나 계층화시키는 방법으로 디자인 패턴은 낮은 결합도의 시스템을 만들도록 한다.

디자인 패턴 : 추상 팩토리, 가교, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자

7.서브클래싱을 통한 기능 확장. 일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법이다. 많은 디자인 패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의하는 방법을 도입한다.

디자인 패턴 : 가교, 책임 연쇄, 장식자, 감시자, 전략

8.클래스 변경이 편하지 못한 점.

디자인 패턴 : 적응자, 장식자, 방문자



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론16-1?category=828277 [IT 고인물]

---
---


[응용 프로그램]

내부 재사용, 유지보수성 및 확장성

 

[툴킷(toolkit)]

툴킷이란 일반적은 목적의 유용한 기능을 제공하는 재사용 가능한 클래스들의 집합체. 툴킷은 코드 재사용을 강조한 것으로 서브루틴 라이브러리와 동일한 객체지향 라이브러리인 셈이다.

 

[프레임워크(framework)]

프레임워크는 특정한 부류의 소프트웨어에 재사용성을 부여하여 개발할 수 있도록 만들어 주는 관련 클래스들의 집합이다. 프레임워크의 재정의란 프레임워크에 정의한 클래스를 상속받아 특정 응용프로그램을 지원하는 서브클래스를 정의하는 것을 뜻한다. 프레임워크는 응용프로그램에 대한 뼈대를 제공한다. 즉, 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들 간의 상호작용, 객체와 클래스 조합 방법, 제어 흐름에 대해 미리 정의한다. 프레임워크는 코드의 재사용보다는 설계의 재사용을 강조한다.

응용프로그램의 설계는 프레임워크에 종속되어 있어서 프레임워크의 변경에 매우 민감할 수밖에 없다. 그러므로 응용프로그램과 프레임워크 사이의 결합도는 낮을수록 더 좋다.

패턴과 프레임워크 사이의 차이점

1.디자인 패턴이 프레임워크보다는 더 추상적이다. 디자인 패턴의 목적이 설계의 의도나 장단점 등을 설명하려는 것이지 구현한 결과물을 제공하려는 것은 아니기 때문이다.

2.디자인 패턴은 프레임워크에 비해서 소규모의 아키텍처 요소이다. 일반적으로 프레임워크는 여러 디자인 패턴을 포함한다.

3.디자인 패턴은 프레임워크에 비해 덜 특수화되어 있다. 프레임워크는 어떤 특정 응용프로그램 영역을 목표로 한다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론16-2?category=828277 [IT 고인물]

---
---

[1.7 디자인 패턴을 고르는 방법]

-패턴이 어떻게 문제를 해결하는지 파악한다.

-패턴의 의도 부분을 본다.

-패턴들 간의 관련성을 파악한다.

-비슷한 목적의 패턴들을 모아서 공부한다.

-재설계의 원인을 파악한다.

-설계에서 가변성을 가져야 하는 부분이 무엇인지 파악한다.

 

[1.8 디자인 패턴 사용 방법]

1.전체를 훑는 기분으로 끝까지 한 번 읽는다.

2.다시 처음으로 돌아가 ‘구조(Structure)’, ‘참여자(Participant)’, ‘협력 방법(Collaboration)’ 절을 다시 공부한다.

3.더 확실하게 이해하기 위해서 예제 코드 부분을 살핀다.

4.응용프로그램에 의미 있는 이름으로 패턴의 참여자 이름을 결정한다.

5.클래스를 정의한다.

6.패턴에 정의한 연산에 대해서 응용프로그램에 적합한 이름을 정의한다.

7.패턴에 정의한 책임과 협력 방법을 수행하도록 연산을 구현한다.

 

<생성>

- 추상 팩토리 : 제품 객체군

-빌더 : 복합 객체 생성 방법

-팩토리 메서드 : 인스턴스화될 객체의 서브클래스

-원형 : 인스턴스화될 객체 클래스

-단일체 : 클래스의 인스턴스가 하나일 때

 

<구조>

- 적응자 : 객체에 대한 인터페이스

-가교 : 객체 구현

-복합체 : 객체의 합성과 구조

-장식자 : 서브클래싱 없이 객체의 책임성

-퍼사드 : 서브시스템에 대한 인터페이스

-플라이급 : 객체의 저장 비용

-프록시 : 객체 접근 방법

 

<행동>

- 책임 연쇄 : 요청을 처리하는 객체

-명령 : 요청의 처리 시점과 처리 방법

-해석자 : 언어의 문법과 해석 방법

-반복자 : 집합 객체 요소들의 접근 방법 및 순회 방법

-중재자 : 어떤 객체들이 어떻게 상호작용하는지

-메멘토 : 언제 어떤 정보를 객체의 외부에 저장하는지

-감시자 : 다른 객체에 종속적인 객체 수, 종속적인 객체들의 상태 변경 방법

-상태 : 객체의 상태

-전략 : 알고리즘

-템플릿 메서드 : 알고리즘의 단계

-방문자 : 클래스의 변경 없이 객체에 적용할 수 있는 연산

 

디자인 패턴은 아무렇게나 적용되어서는 안 된다. 종종 디자인 패턴은 간접 접근(위임과 같은 기법)을 도입함으로써 융통성과 다양성을 갖지만, 설계를 복잡하게 만들고 성능을 떨어뜨리는 결과를 가져오기도 한다. 어떤 패턴을 썼을 때 얻는 부분과 잃는 부분이 무엇인지 평가할 때는 ‘결과’ 절을 잘 읽어보자.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-1장-서론1718?category=828277 [IT 고인물]

---
---

[Chapter 2. 사례 연구: 문서 편집기 설계]

WYSIWYG: What You See Is What You Get, 눈에 보이는 대로 출력됨

 

[2.1 설계 문제들]

1.문서 구조 : 문서의 내부를 어떻게 표현할 것인지

2.서식 설정

3.사용자 인터페이스 꾸미기

4.여러 룩앤필(look and feel) 표준의 지원

5.여러 윈도우 시스템의 지원

6.사용자 조작

7.철자 검사와 붙임표 처리

 

[2.2 문서 구조]

문서는 문자, 선, 다각형 등 기본적인 그래픽 요소를 단순히 배열한 것입니다. 이런 요소들을 통해서 문서의 전체 내용을 정의할 수 있게 된다.

인터페이스를 직관적이고 간단하게 만들어야 한다.

편집기의 내부 표현은 다음 항목들을 지원해야 한다.

-문서의 물리적 구조 유지 기능

-문서를 시각적으로 생성하고 표현하는 부분

-내부 표현 영역의 요소들과 화면에 표시된 요소들을 사상하는 부분

 

<제약 사항>

1.문자와 그래픽을 동일하게 다뤄야 한다.

2.단일 요소와 그룹 요소를 구분해서 구현하면 안된다.

그러나 가끔은 분석 대사에 따라서 분석 방법이 달라져야 한다. 다시 말해, 어떤 때는 모든 요소들을 서로 동일하게 다루어야 하고, 어떤 때는 서로 구분해서 처리해야 한다.

 

[재귀적 합성]

계층적으로 구조화된 정보를 보여주는 가장 일반적인 방법으로 재귀적 합성(Recursive Composition) 기법이 있다.

물리적 구조를 표현하는 데 있어서, 각각의 주요 요소를 모두 객체로 만들어 구현할 수 있다. 이렇게 하면 글자나 그래픽과 같은 시각적 요소뿐만 아니라 보이지 않는 구조적 요소(선, 열 등)도 포함할 수 있다.

 

[글리프(Glyph)]

화면에 표시되는 구성요소를 포괄적으로 일컫는 개념인 글리프는, 모든 객체를 위한 추상 클래스인 Glyph로 정의하려 한다. 글리프의 서브클래스는 기본적인 그래픽 요소(문자와 이미지 같은)와 구조적 요소(행과 열 같은)를 정의한다.

글리프는 세 가지의 기본적인 책임을 맡고 있다.

1.어떻게 자기 자신을 그리는지에 대한 부분

2.차지하는 영역이 얼마나 되는지에 대한 부분

3.자신의 자신들과 부모가 누구인지를 가리키거나 참조하는 부분

글리프의 서브클래스는 Draw() 연산을 재정의해서 윈도우에 자신을 그린다. Draw() 연산의 호출이 일어날 때 Window 객체에 대한 참조자를 전달받는다. Window 클래스는 스크린의 윈도우에 텍스트와 기본 도형을 표현하기 위한 그래픽 연산을 정의한다. Glyph의 서브클래스인 Rectangle 클래스는 Draw()연산을 재정의 한다.

부모 클래스는 서브클래스가 얼마나 많은 공간을 차지하는지 알아야 할 때가 있다.

글리프는 자식을 가질 수 있기 때문에, 그 자식들을 추가하고, 삭제하며, 접근할 공통의 인터페이스가 필요하다.

 

[복합체 패턴]

복합체 패턴은 객체지향 관점에서 재귀적 합성을 표현하는 패턴이다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계2122?category=828277 [IT 고인물]

---
---

[2.3 서식 설정]

편집기에서 문서 표현과 서식 설정은 완전히 다른 영역이다. 문서의 물리적 구조를 저장하는 능력이 서식에 맞는 특정 구조를 만들어 내는지를 알려주지는 않는다. 이런 부분은 거의 Lexi 구현자의 책임으로 돌아간다. 구현자는 텍스트를 라인으로 나누고 라인을 열로 구분하는 등 사용자의 수준 높은 기대에 부응해야 한다. Lexi의 서식 설정(formatting) 알고리즘은 이것을 모두 고려해서 만들어야 한다.

 

[서식 설정 알고리즘의 캡슐화]

중요하게 고려할 사항은 서식 설정의 품질과 서식 설정에 필요한 속도를 어떻게 균형 있게 잘 맞추느냐 하는 것이다. 다시 말해, 문서가 화면에 표시되는 외양의 품질을 유지하면서 적정한 시간 안에 처리되어야 한다. 이러한 균형을 맞추려면 여러 가지 요인들을 고려해야 하는데, 모든 요인을 컴파일 시점에 결정할 수는 없다. 속도와 저장 용량 간의 균형도 필요하다. 얼마나 많은 정보를 저장하고 있느냐에 따라 속도가 빨라지기도, 느려지기도 하기 때문이다.

서식 설정 알고리즘을 쉽게 변경할 수 있도록 설계해야 한다. 이를 위해서, 알고리즘을 별도의 객체로 둘러싸서 쉽게 대체 가능하도록 할 수 있다. 클래스 계층의 루트인 최상위 클래스는 다양한 서식 설정 알고리즘을 지원할 수 있는 인터페이스를 정의하고, 각 서브클래스가 특별한 아록리즘을 수행하도록 인터페이스를 구현한다. 그리고 Glyph 클래스의 서브클래스를 통해 특정 알고리즘 객체를 이용하게 하여 자식들을 자동으로 구조화시킬 수 있다.

 

[합성자와 복합]

서식 설정 알고리즘을 캡슐화할 수 있는 객체를 Compositor클래스로 정의한다. Compositor 클래스가 포맷을 지정하는 글리프는 Glyph 클래스의 특정 서브클래스인 Composition 클래스와 자식 관계를 갖는 객체들이다. Composition 클래스는 Glyph 클래스의 서브클래스이면서 다시 Glyph 클래스의 인스턴스를 집합 관계의 자식으로 포함한다. Composition 객체는 서식을 설정할 때 Compositor 객체의 Compose() 연산을 호출한다. 이후에 이 객체는 Composition 객체와 자식 관계에 있는 인스턴스를 라인 분리 알고리즘에 따라서 반복적으로 생성하면서 새로운 Row와 Column 글리프를 삽입한다.

각 Compositor 클래스는 서로 다른 라인 ㅂ누리 알고리즘을 구현한다. 이렇게 Compositor-Composition으로 클래스를 구분해 두면, 문서의 물리적 구조와 다른 서식 설정 알고리즘을 지원하는 코드 사이를 확실히 구분할 수 있다. 클래스 분리는 문서의 물리적 구조를 지원하는 코드 및 다른 서식 설정 알고리즘을 위한 코드가 확실히 분리될 수 있도록 해준다.

 

[전략 패턴]

알고리즘을 객체로 캡슐화하는 것, 이것이 전략 패턴의 의도이다. 이 전략 패턴의 주요 참여자는 Strategy 패턴을 구현한 객체(서로 다른 알고리즘들을 캡슐화한)와 이 객체가 동작할 전후 관계, 즉 동작 환경(context)이다.

Compositor 클래스 : Strategy 클래스 - 서로 다른 서식 설정 알고리즘을 캡슐화

Compositon 클래스 : Compostor 클래스의 전략에 대한 Context 클래스

전략 패턴을 적용하는 데 가장 중요한 것은 전략과 동작 환경에 대한 인터페이스를 충분히 일반화해야 한다는 것이다. 새로운 알고리즘을 지원하기 위해서 전략이나 배경 인터페이스를 변경할 필요는 없다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계23?category=828277 [IT 고인물]

---
---

[2.4 사용자 인터페이스 장식하기]

새로운 장식을 쉽게 추가하려면(특히,런타임에), 상속을 써서 사용자 인터페이스에 장식 요소를 추가하면 안 된다. 다른 사용자 인터페이스에는 이런 장식 요소가 있을지도 모른다는 가정 아래 설계해야만 사용자 인터페이스 설계의 유연성을 보장할 수 있다.

 

[투명성 포함]

프로그래밍 관점에서 볼 때, 사용자 인터페이스에 장식을 추가한다는 것은 결국 기존 코드의 확장이 필요하다는 뜻을 내포한다. 장식의 종류가 많아질 때마다 클래스를 만드는 해법은 언젠가는 더 이상의 확장을 불가능하게 한다. 이럴 때는 객체 합성이 훨씬 더 유연한 확장 방법이 될 수 있다.

Border 클래스의 인스턴스로 기존 글리프들을 장식하면 된다. 이 과정을 통해서 복합할 수 있는 두개의 후보가 생기게 된다. 하나는 글리프이고, 다른 하나는 테두리이다. 이렇게 하면, 추가한 장식 클래스에 해당하는 Border 클래스에 테두리를 그리는 코드만 작성하는 것으로 간단히 정리되며, 다른 기존의 클래스는 변경하지 않아도 된다. 외관을 갖는 테두리도 개념적으로는 글리프의 일종이기 때문에 Border 클래스도 Glyph의 서브클래스여야 한다.

평범한 글리프이건 테두리를 포함한 글리프이건 동일하게 취급할 수 있어야 한다. 즉, Border 인터페이스가 Glyph 인터페이스와 일치한다는 뜻이다. 이런 관계를 보장하기 위해 Border 클래스를 Glyph 클래스에서 상속한다.

 

<투명한 포함(transparent enclosure) 개념>

1.단일 자식(다른 말로 단일 구성요소)에 기반을 둔 합성고ㅏ

2.호환되는 인터페이스의 개념을 조합한 것

 

[단일 글리프]

일반적 복합에서 부모 객체는 무수히 많은 자식들을 가질 수 있다. 한번에 하나 이상의 객체를 꾸밀 수도 있지만, 그러게 되면 꾸민다는 개념에 다양한 종류의 복합을 혼합해야 한다. 즉, 장식마다 새로운 개념을 만들어내는 셈이다.

복합을 위해서는 이미 갖고 있는 클래스를 이용하고, 새로운 장식에 대해서만 새로운 클래스를 만드는 것이 바람직하다. 장식을 복합과 독립적으로 관리함으로써 장식에 관련된 클래스를 단순화할 수 있고 클래스의 수도 줄일 수 있다.

 

[장식자 패턴]

장식자 패턴은 “투명한 포함” 개념에 의해 장식을 지원하는 클래스와 포함되는 객체들 사이의 관계를 잡아낸 것이다. 장식자 패턴에서 “장식은”은, 객체에 추가할 수 있는 모든 책임에 해당한다. 장식에 해당하는 예로는, 처리부를 갖는 추상 구문 트리, 새로운 상태 전이를 갖는 유한 상태 오토마타(finite state automata), 속성 태그를 갖는 영속성 객체망 등이 있는데, 이것은 기본 객체에 추가적인 책임이 부여된 예들이다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계24?category=828277 [IT 고인물]


---
---

[2.5 다양한 룩앤필 표준 지원]

하드웨어와 소프트웨어 플랫폼 간의 이식성을 지원하는 것은 시스템 설게에 매우 중요한 일이다. 이식성에서 걸림돌이 되는 한 가지는 룩앤필 표준의 다양성이다. 이 표준은 응용프로그램이 어떻게 화면에 표시되고 어떻게 사용자의 요청에 반응하는지에 대한 표준 지침을 정의한다. 모티프를 기반으로 한 응용프로그램들은, 다른 플랫폼에서 이에 상응하는 응용프로그램과 완전히 똑같은 룩앤필을 갖고 있지는 않는다. 하나 이상의 플랫폼에서 돌아가는 응용프로그램은 그 플랫폼에서 제공하는 고유한 사용자 인터페이스 스타일 지침을 따라야 한다.

런타임에도 룩앤필을 변경할 수 있는, 최고의 유연성을 지원하는 설계는 만드는 것이 목표이다.

 

[객체 생성의 추상화]

우리 눈에 보이고 Lexi의 사용자 인터페이스와 상호작용하는 것 모두가 글리프이다. 보이지 않는 행이나 열도 글리프이다. 버튼이나 스크롤바, 메뉴 등과 같이 사용자 인터페이스에서 어떤 요소들을 제어할 때 동작하는 글리프들을 “위젯(widget)”이라고 한다.

다양한 룩앤필을 구현하기 위해 두 가지 종류의 Glyph 클래스

1.위젯의 각 카테고리별로 Glyph 클래스를 상속받는 서브클래스 집합

2.각 추상 클래스를 상속하여 서로 다른 룩앤필을 구현하는 서브클래스 집합

서로 다른 룩앤필에 대한 위젯들을 구분할 필요가 있다. C++의 생성자를 이용해서는 이런 ㅂ아식의 구현이 불가능하다. 즉, 생성자에 어떤 특정 스타일의 버튼을 생성하도록 직접 코딩하게 되면 런타임 스타일을 선택할 수 없다. 모든 위젯의 생성자마다 새로운 플랫폼에 적합한 인스턴스를 생성하도록 변경해야 한다면, 새로운 이식 요청이 들어올 때마다 행해야 하는 유지보수는 정말 끔찍한 일이 될 것이다.

적당한 위젯을 생성하기 위해 맞춘 룩앤필을 결정하는 방법이 필요하다. 명시적인 생성자 호출도 피하고 싶을 뿐 아니라, 이와 동시에 전체 위젯을 쉽게 변경할 수 있어야 한다. 이 두 마리 토끼는 객체를 생성하는 과정 자체를 추상화함으로써 모두 잡을 수 있다.

 

[팩토리와 제품 클래스]

GUIFactory 클래스는 위젯을 만드는 데 필요한 공통의 인터페이스를 정의하는 추상 클래스이다.

통칭, 팩토리는 제품(product) 객체를 생성한다고 한다. 팩토리는 모티프, 프레젠테이션 매니저별 객체를 생성한다. 게다가 팩토리가 생성하는 제품들은 서로 관련되어 있다. 제품들은 같은 룩앤필을 위한 위젯이다.

그렇다면 어디서 GUIFactory 클래스의 인스턴스를 얻어야 할까? 이를 위해서라면 guiFactory 변수는 전역 변수가 되든지 잘 알려진 클래스의 정적 멤버가 될 수 있을 것이다. 이럴 때 쓰는 패턴이 바로 단일체이다. 한 클래스에서 만든 인스턴스가 오직 하나만 존재할 때 사용할 수 있는 패턴이 바로 단일체 패턴이기 때문이다. 중요한 것은 guiFactory 인스턴스의 초기화는 위젯을 생성하기 전에 이루어지는 것이지 어떤 룩앤필이 필요한지를 알았을 때 이루어지는 것이 아니라는 점이다. 즉, guiFactory 인스턴스는 첫 번째 위젯이 필요할 때 생성된다.

만약 룩앤필을 컴팡리 타임에 결정한다면, 프로그램의 시작부에 새로운 팩토리 인스턴스를 할당하는 단순 대입문을 둠으로써 guiFactory를 초기화하면 된다. 런타임 팩토리를 선택하는 좀더 세련된 방법도 있다. 예를 들어, 문자열과 팩토리 객체를 대응시키는 등록저장소, 즉 레지스트리(registry)를 두고 유지할 수 있다. 레지스트리를 이용하면 플랫폼에 종속된 팩토리를 응용프로그램에 링크할 필요가 없다. 새로운 팩토리가 등장하면 레지스트리에만 등록하면 된다.

 

[추상 팩토리 패턴]

추상 팩토리 패턴의 참가 객체는 팩토리와 제품이다. 이 패턴은 클래스의 인스턴스를 직접 만들지 않고서도 관련된 제품 객체의 군을 생성하는 방법을 정의한다. 어떤 특정 팩토리를 지정하여 이를 통해서 제품을 생성하게 하는 방법으로 원하는 제품을 선택한다. 팩토리의 인스턴스만 바꾸면 전체 제품군을 바꿀 수 있다. 추상 팩토리 패턴은 동일 계열의 제품군을 다룰 수 있다는 점에서 다른 생성 패턴과 다르다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계25?category=828277 [IT 고인물]


---
---

[2.6 다중 윈도우 시스템 지원]

[추상 팩토리 패턴을 사용할 수 있을까요?]

윈도우 시스템 간의 이식성은 앞에서 본 룩앤필 표준에 대한 독립성과는 사뭇 다른 점이 있다. 추상 팩토리 패턴을 적용할 때는 각 룩앤필별로 정확한 위젯 클래스를 정의할 것이라고 가정했다. 즉, 각 위젯별로 하나의 추상 클래스를 추출할 수 있어 추상 팩토리 패턴의 사용이 가능하다. 윈도우 시스템은 각 회사마다 서로 다른 여러 개의 클래스 게층을 이미 가지고 있는데, 이 계층이 서로 호환 가능하다고 볼 수 없기 때문에 각각 위젯별로 공통의 추상 클래스를 정의할 수 없다. 이때는 추상 팩토리 패턴을 적용할 수 없으므로, 제품이 갖는 인터페이스에서 공통된 연산을 정의하는 별도의 위젯 계층을 만들어야 한다. 그래도 다행인 점은 룻앤필 표준에서도 그랬듯이 윈도우 시스템의 인터페이스 역시 심각하게 다르지 않다는 것이다. 단, 하는 일은 비슷하지만 구현하는 방법은 완전히 다르므로 윈도우가 하는 일에 대한 추상화와 이를 구현하는 방버의 추상화를 분리시켜야 한다. 윈도우가 하는 일이란 윈도우 시스템의 인터페이스를 의미하고, 이를 구현하는 방법이란 실제 윈도우 시스템이 제공하는 프로그래밍 인터페이스를 의미한다.

 

[구현 종속성을 캡슐화]

화면에 표시되는 글리프나 글리프 구조를 Window 클래스. 다음과 같은 것들을 캡슐화.

-기본적인 기하학적 도형을 그릴 수 있는 연산을 제공한다.

-아이콘 상태가 될 수 있고 아이콘 상태에서 해제될 수도 있다.

-크기 변경이 가능하다.

-요청이 있을 때 콘텐츠를 (다시) 그린다.

윈도우 시스템과 상관없이 서로 다른 윈도우 시스템에서 기능성을 확장할 수 있다.

이를 위한 다음 두가지의 극단적인 원칙

1.기능성의 교집합으로만 인터페이스를 정의

2.기능성의 합집합으로만 인터페이스를 정의

이 두방법은 모두 문제가 있기 때문에, 그 중간 방법을 선택해야 할 것이다.

Window는 추상 클래스이고 Window를 상속하는 서브클래스들이 사용자가 다룰 서로 다른 종류의 윈도우를 지원한다. 예를 들어, Window 서브클래스는 응용프로그램 윈도우, 아이콘, 경고 창 등 다양한 종류의 윈도우를 지원한다.

윈도우 추상화는 반드시 기존의 윈도우 시스템이 제공하는 방법으로 구현되어야 한다. 한 가지 방법은, Window 클래스와 서브클래스들을 각각 윈도우 플랫폼마다 서로 다른 버전으로 구현하는 것이다. 그러나 이때는 유지보수가 매우 어렵다. 또 다른 방법은 Window 계층의 각 클래스에 대해 구현 플랫폼별 서브클래스를 모두 생성하는 것이다. 이 방법을 쓸 때에는 서브클래스의 수가 너무 많아진다는 문제가 발생한다. 그리고 방금 말씀드린 두 방법은 공통적인 또 다른 단점을 가지고 있다. 프로그램을 컴파일한 후에는 윈도우 시스템을 변경할 수 없다는 것이 그 단점이다. 결국 윈도우 시스템마다 별도의 실행 파일을 유지할 수 밖에 없다. 또 다른 방법으로, 서식 설정이나 장식을 설계할 때 썼던 방법처럼 다양성이 존재하는 부분을 별도로 캡슐화하면 된다. 이때 다양성을 갖는 대상은 윈도우 시스템별 구현이다. 윈도우 시스템의 기능을 하나의 인터페이스 객체로 캡슐화했다면 우리는 Window 클래스와 이의 서브클래스를 구현할 때 이 인터페이스를 따라서 구현해야 한다. 적절한 윈도우 시스템을 캡슐화한 객체를 윈도우 시스템 쪽으로 전달해 주면 된다. 심지어 런타임에도 윈도우를 설정할 수 있다.

 

[Window와 Windowlmp]

WindowImp는 추상 클래스이고, 윈도우 시스템에 종속된 코드를 캡슐화한다. Lexi가 특정 윈도우 시스템에서 제대로 동작하도록, 각 윈도우 객체를 WindowImp의 서브클래스 인스턴스로 설정할 것이다. 윈도우 시스템 구현이 WindowImp 클래스 속으로 숨어 들어갔기 때문에, 이제는 Window 클래스를 윈도우 시스템에 종속적인 내용으로 더럽히지 않아도 된다.

<WindowImp 서브클래스들>

<WindowImp를 써서 Windows 설정하기>

아직 다루지 않은 문제는 적당한 WindowImp 서브클래스의 인스턴스를 어떻게 Window 쪽에서 얻는가 하는 문제이다. 즉, _imp 멤버 변수를 언제 초기화하고, 어떤 윈도우 시스템을 사용해야 하며, 누가 알고 있어야 하는지와 관련된 문제이다. 몇가지 해결 방법이 있지만, 여기서는 추상 팩토리 패턴을 사용하는 방법만 살펴보자.

먼저, WindowSystemFactory 클래스를 만들어서 윈도우 시스템별 구현 객체의 각 종류를 생성하는 인터페이스를 정의한다. 그러고 나서 각각의 윈도우 시스템마다 필요한 팩토리를 정의한다.

 

[가교 패턴]

Window 클래스와 WindowImp 클래스 간의 관련성은 가교 패턴의 한 예이다. 서로 독립적으로 확장되지만 함께 동작해야 하는 개념들을 별도의 클래스 계층으로 분리하는 것이 가교 패턴의 목적이다. 이렇게 두 개의 계층으로 분리할 때는 두가지의 기준을 세워야 한다. 하나는 논리적 개념에 해당하는 윈도우이고, 다른 하나는 그 윈도우에 대한 서로 다른 물리적 구현이다. 가교 패턴을 적용하면, 윈도우 시스템에 종속적인 구현과 전혀 상관없이 논리적인 윈도우 추상화를 확장할 수 있고, 그 반대로 추상적 개념과 무관하게 새로운 윈도우 시스템의 구현도 추가할 수 있다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계26?category=828277 [IT 고인물]

---
---

[2.7 사용자 조작]

WYSIWYG. 즉, 텍스트를 입력,삭제하며 삽입 지점으로 커서를 이동하고 텍스트의 범위를 선택하는 기능은 문서 화면을 마우스로 직접 클릭하고 키보드로 타이핑함으로써 가능하다.

사용자 조작을 어느 특정 사용자 인터페이스에만 국한시키고 싶지는 않다. 왜냐하면 여러 개의 사용자 인터페이스가 동일한 연산을 수행할 수도 있기 때문이다. 예를 들어, 페이지를 바꾸기 위해서 메뉴를 이용할 수도 있고, 페이지 이동 버튼을 이용할 수도 있다. 게다가, 한 가지의 조작 기능은 여러 다른 클래스들에서 구현된다. 구현자 쪽에서는 이런 기능을 위해 구현과 사용자 인터페이스 클래스 사이에 종속성을 만든느 일은 하지 않으려고 한다. 결합도가 강한 구현을 만들게 되면 이해하기도 어렵고 확장이나 유지보수가 어려워지기 때문이다.

 

[요청의 캡슐화]

호출할 함수로 MenuItem 클래스를 매개변수화할 수도 있겠지만, 이것도 다음 세가지 이유 때문에 완벽한 해법이 되지는 못하다.

1.실행,취소 문제를 처리할 수 없다.

2.함수에 상태를 결합시키기 어렵다.

3.함수를 확장하기 어렵고, 함수의 일부를 재사용하기도 쉽지 않다.

이런 이유로, 함수를 매개변수로 받는 것이 아니라 객체를 MenuItem 매개변수로 정의하려 한다. 이렇게 하면, 상속을 통해서 요청 구현을 확장하거나 재사용할 수 있다. 게다가, 실행,취소 서비스를 구현할 수 있고 상태를 저장할 수 있는 공간을 객체 안에 정의할 수도 있다.

 

[Command 클래스와 서브클래스]

먼저, 요청을 발생시키는 인터페이스를 제공하기 위해 Command 추상 클래스를 정의한다. 이 인터페이스는 요청 발생용 인터페이스의 기본으로, “Execute” 추상 연산 하나만 있다. 버튼과 다른 위젯들도 이와 동일한 방식으로 명령들을 처리한다는 점도 주목할 부분이다.

 

[취소 가능성]

실행,취소는 대화식 응용프로그램에서 중요한 기능이다. 명령을 실행하고 취소하기 위해서는 Command 인터페이스에 Unexecute() 연산을 추가해야 한다. Unexecute() 연산은 바로 전에 수행한 연산의 처리 결과를 되돌리는 것이다. 이를 위해서는 Execute() 연산이 저장한 취소 정보(undo information)를 이용한다. 가끔 이런 취소 가능성(undoability)을 런타임에 결정해야 할 때도 있다. 명령을 수행한 후 나타난 결과에 어떠한 영향도 미치지 못했다면 해당 취소 명령도 수행할 필요가 없다.

그러므로 명령이 취소 가능한 것인지 아닌지를 판단하기 위해서는 Command 인터페이스에 Reversible() 연산을 추가해야 한다. Reversible()연산은 boolean 값을 반환하는 연산으로, 각 서브클래스에서 이 연산이 취소 가능한지 아닌지를 판단하여 참 또는 거짓을 반환하도록 재정의할 수 있다.

 

[명령 이력]

실행과 취소를 임의 수준으로 지원하도록 만드는 작업의 마지막 단계는 명령 이력(command history)을 정의하는 것이다. 즉, 실행한(취소된 명령이 있을 때에는 실행이 취소된) 명령의 리스트를 관리하는 것이다.

 

[명령 패턴]

Lexi의 사용자 명령어는 명령 패턴을 응용한 것으로, 명령 패턴은 요청을 어떻게 캡슐화하는지 설명하는 패턴이다. 명령 패턴은 요청을 발생시키는 데 필요한 균일한 인터페이스를 규정해 주기 때문에, 사용자 쪽에서는 서로 다른 요청을 동일하게 처리할 수 있다. 또한, 이 패턴에는 취소와 재실행을 처리하는 인터페이스를 추가할 수도 있다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계27?category=828277 [IT 고인물]

---
---

[2.8 철자 검사 및 붙임표 연결]

다양한 기능이 계속적으로 추가될 수 있는 틀을 만들고 싶다. 그러나 이런 기능을 추가할 때마다 Glyph 클래스나 이를 상속하는 서브클래스들을 변경하고 싶지는 않다. 이 퍼즐을 풀려면 두가지 조각을 맞춰야 한다. 1.하나는 분석될 정보에 접근하는 것인데, 이 정보는 문서 구조를 나타내는 여러 글리프에 흩어져 있다. 2.다른 하나는 분석을 직접 하는 것이다.

 

[흩어진 정보에 대한 접근]

우리가 분석해야 하는 텍스트는 글리프 객체의 계층 구조에 흩어져 있다.

Lexi에서 쓰는 접근 방법은 서로 다른 데이터 구조를 포괄할 수 있어야 하며, 서로 다른 순회 방법[postorder, inorder, preorder 등]이 지원되어야 한다.

 

[접근과 순회 방법을 캡슐화하기]

글리프 추상화의 가장 큰 의의는 자식들을 저장하는 자료 구조를 외부에 숨기는 것이었다. 이렇게 해야만 다른 클래스에 영향을 주지 않고 자료 구조를 마음대로 변경할 수 있다. 이를 위해서 어떤 데이터 구조에도 치우치지 않는 인터펭시ㅡㄹ르 정의해야 한다. 즉, ㅇ니터페이스를 보고 글리프가 사용하는 데이터 구조가 무엇인지를 판단할 수 있으면 안 된다.

클래스는 순회 방법이나 접근 방법을 나타내는 나열형(enumerated) 값 중 하나를 선택해서 연산의 매개변수로 전달한다. 그러나 이 방법에도 문제가 있다. 새로운 순회 방법을 추가하려면 나열형 값을 변경하거나 새로운 연산을 추가해야 하기 때문이다.

바로 이럴 때 iterator 객체를 도입할 수 있다. 이 객체의 목적은 다양한 접근과 순회 방법을 일반화해서 정의하는 것이다. 상속을 이용해서 다른 데이터 구조에 동일하게 접ㄱ느할 수 있을 뿐더러 새로운 종류의 순회도 제공할 수 있다. 그리고 glyph 인터페이스를 변경하거나 기존 구현을 어지럽히지 않아도 된다.

 

[iterator(반복자) 클래스와 서브클래스]

구조 접근과 순회에 필요한 일반 핑터페이스를 정의하는 용도로 Iterator 추상 클래스를 사용한다. Iterator의 각 서브클래스는 자신이 순회할 구조에 대한 참조자를 가지며, 서브클래스의 인스턴스는 자신이 생성될 때 자신이 순회할 데이터 구조에 대한 참조자로 초기화된다. Iterator 인터페이스에는 순회를 제어하기 위해 First(), Next()와 IsDone() 연산이 있다. Iterator 클래스 계층의 덕택으로, 새로운 종류의 순회 방법을 추가할 때 기존 Glyph 클래스를 수정하지 않아도 된다. PreorderItrator 클래스를 가지고 한 것처럼 Iterator 클래스의 서브클래스를 만들고 새로운 순회 ㅂ아법을 추가하면 끝이다. Iterator는 순회의 상태에 대한 각자의 사본을 저장하고 있기 때문에, 심지어 하나의 구조에 대해서도 여러 개의 순회를 동시에 진행할 수 있다. C++의 템플릿을 사용하면 쉽게 구현할 수 있다.

 

[반복자 패턴]

반복자 패턴은 객체 구조에 대한 접근 및 순회 방법을 지원하기 위한 기법을 잡아낸 패턴이다. 반복자 패턴은 다양화될 수 있는 개념들을 캡슐화하면 어떻게 유연성과 재사용성 헤택을 취할 수 있는지 보여주는 예이다.



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계28?category=828277 [IT 고인물]

---
---

[순회, 그리고 순회 중의 작동]

순회와 순회 중 작동을 따로 떼어놓을 수 있다면 훨씬 더 높은 유연성과 재사용성을 얻을 수 있다. 분석 방법마다 사용되는 순회 방법이 한 가지가 아니라 여러 가지이기 때문이다. 분석과 순회는 분리해��� 한다.

분석 방법은 글리프의 종류를 구별할 수 있어야 한다. 쉽게 생각할 수 있는 한 가지 방법은 분석 기능을 Glyph 클래스 자체에 넣는 것이다. 이 방법의 문제는 새로운 분석이 추가될 때마다 모든 Glyph 클래스를 변경해야 한다는 것이다.

 

[분석 작업을 캡슐화하기]

분석 작업 자체를 별도의 객체로 캡슐화할 필요가 있다. 분석 작업을 나타내는 별도의 클래스를 정의하고, 이 클래스의 인스턴스를 반복자와 함께 사용한다. 반복자는 문서 구조를 이루는 원소들을 하나씩 순회하고, 반복자가 방문한 원소에 대해서 분석 객체가 분석을 처리한다. 이 방법을 쓰려면 근본적인 의문점 하나를 해결해야 한다. 분석 객체가 타입 검사와 다운캐스트 기능에 의존하지 않고 어떻게 글리프이 종류를 구분할 수 있을까 하는 것이다.

각 글리프를 만날 때마다 철자 검사기를 매개변수로 넘겨 CheckMe() 연산을 호출하면서 글리프 구조를 순회할 수 있게 되었다. 따라서 철자 검사를 적용할 각 글리프를 효과적으로 식별하고 다음 번 요소로 바로 진행할 수 있다.

하나의 인터페이스로 정의하면 서로 다른 알고리즘을 이용할 때 다형성의 특성도 얻을 수 있다. 즉, CheckMe(SpellingChecker&)연산과 같이 분석 의존형 연산 대신에 좀더 일반적인 매개변수를 받는 분석 독립적 연산으로 바꿀수 있다는 뜻이다.

 

[Visitor 클래스와 서브클래스]

구조를 순회하는 도중에 그 구조를 구성하는 다른 객체에 “방문(visit)”하여 적절한 일을 수행하는 객체의 클래스 : visitor(방문자)

구조 내의 글리프를 방문하는 추상 인터페이스를 가진 Visitor 클래스

각기 다른 분석 작업을 수행하는 쪽은 Visitor 클래스의 서브 클래스

연산의 이름은 좀더 범용적인 Visitor 인터페이스를 따라야 한다.

새로운 분석 작업을 추가하고 싶으면 그 분석 작업을 Visitor의 서브클래스로 정의하면 끝이며, 글리프 클래스 쪽은 건드리지 않아도 된다.

 

[방문자 패턴]

이 패턴의 주요 참여자가 바로 Visitor 클래스와 서브클래스이다. Visitor 패턴은 Glyph 클래스의 변경 없이도 추가 가능성을 내포한 글리프 구조 분석을 가능하게 하려고 사용한 기법을 잡아낸 것이다. 꼭 복합 객체에만 적용할 수 있는 것이 아니라 모든 구조에 다 적용할 수 있다. 방문자가 방문하는 클래스들이 꼭 동일한 부모 클래스를 가질 필요도 없다.

방문자 패턴을 사용하기 전에 반드시 확인해야 하는 부분 하나가 있다. 가장 자주 변경되는 클래스 계층이 무엇인가 하는 것이다. 구조 클래스 구조가 안정된 상태에서 객체에게 여러 가지 일을 많이 시키고 싶다면 방문자 패턴을 사용하는 것이 좋다. 기존 클래스 구조에 새로운 (서브)클래스가 추가되면 반드시 Visitor 클래스에 Visit...() 연산을 추가해야 한다는 것을 잊지 말아야 한다.

 

[2.9 요약]

1.문서의 물리적 구조를 표현하기 위한 복합체 패턴

2.서로 다른 서식 설정 알고리즘을 위한 전략 패턴

3.사용자 인터페이스를 꾸미기 위한 장식자 패턴

4.여러 개의 룩앤필 표준을 지원하기 위한 추상 팩토리 패턴

5.여러 개의 윈도우 플랫폼을 허용하기 위한 가교 패턴

6.취소 가능한 사용자 연산을 위한 명령 패턴

7.객체 구조를 접근하고 순회하기 위한 반복자 패턴

8.문서 구조의 구현을 복잡하게 하지 않고 다수의 분석 기능을 제공하기 위한 방문자 패턴



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-2장-사례-연구문서-편집기-설계2829?category=828277 [IT 고인물]

---
---

[디자인 패턴 카탈로그]

[Chapter3 생성 패턴]

생성 패턴(creational pattern)은 인스턴스를 만드는 절차를 추상화하는 패턴이다. 이 범주에 해당하는 패턴은 객체를 생성,합성하는 방법이나 객체의 표현 방법과 소프트웨어 시스템을 분리해 준다. 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생성 패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있다.

생성 패턴이 나오면 항상 따라다니는 이야기가 두 개가 있다. 첫째, 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화한다. 둘째, 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려준다. 결론적으로, 생성 패턴을 이용하면 무엇이 생성되고, 누가 이것을 생성하며, 이것이 어떻게 생성되는지, 언제 생성할 것인지 결정하는 데 유연성을 확보할 수 있게 된다.

생성 패턴으로 분류되는 패턴은 여러 개인데, 이런 여러 생성 패턴들은 서로 보완적일 수도 있고 선택되기 위해 서로 경쟁적일 수도 있다. 즉, 동일한 문제 해결을 위해서 어떤 생성 패턴을 사용해야 할지 결정을 내리기 어렵다.

 

<생성 패턴 사용 예시>

-CreateMaze가 방, 벽, 문을 생성하기 위해서 생성자를 이용하지 않고 가상 함수를 호출하도록 구현되어 있다면, 이 가상 함수의 실제 구현을 다양한 방법으로 변경할 수 있다. ⇒ 팩토리 메서드 패턴

-CreateMaze가 방, 벽, 문을 생성하기 위해 생성 방법을 알고 있는 개체를 매개변수로 넘겨받을 수 있다면, 생성 방법이 바뀔 때마다 새로운 매개변수를 넘겨받음으로써 생성할 객체의 유형을 달리할 수 있다. ⇒ 추상 팩토리 패턴

-CreateMaze가 생성하고자 하는 미로에 방, 문, 벽을 추가하는 연산을 사용해서 새로운 미로를 만들 수 있는 객체를 넘겨받는다면 미로를 만드는 방법이나 변경을 이 객체의 상속을 통해서 해결할 수 있다. ⇒ 빌더 패턴

-CreateMaze를 이미 만든 다양한 방, 문, 벽 객체로 매개변수화하는 방법도 가능한데, 이미 만든 객체를 복사해서 미로에 추가하면, 이들 인스턴스를 교체하여 미로의 복합 방법을 변경할 수 있다. ⇒ 원형 패턴

-한 게임에 오로지 하나의 미로 객체만 존재할 수 있고 그 게임에서 돌아가는 모든 게임 객체들이 이 미로에 접근이 가능하도록 보장한다. 전역 변수, 전역 함수 의존할 필요가 없어진다. ⇒ 단일체 패턴



출처: https://yrok.tistory.com/entry/GoF의-디자인-패턴Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-디자인-패턴-카탈로그3장-생성-패턴?category=828277 [IT 고인물]

---
---




