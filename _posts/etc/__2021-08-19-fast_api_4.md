---
header:
  teaser            : # ì¸ë„¤ì¼ ì´ë¯¸ì§€ /assets/images/face_army.jpg
title               : FastAPI \#4 # ì œëª©
excerpt             : Python FastAPI Framework \#4 # ì¸ë„¤ì¼ í•œì¤„ ìš”ì•½
last_modified_at    : 2021-08-19 # ë§ˆì§€ë§‰ ìˆ˜ì •ì¼
categories          : etc
tags                : FastAPI Python
toc                 : # ëª©ì°¨ ì‚¬ìš©ì—¬ë¶€
toc_label           : # ëª©ì°¨ ì œëª©
# {: .notice--info}
---

---
## ì¶œì²˜ : [FastAPI](https://fastapi.tiangolo.com/)

ğŸš« ì•„ë˜ ë‚´ìš©ì€ ì£¼ê´€ì ì¸ ìƒê°ì´ë¯€ë¡œ ì‚¬ì‹¤ê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---
---

## JSON Compatible Encoder

DBì— ì €ì¥ì„ í•  ë•Œì²˜ëŸ¼,  
ì–´ë–¤ ë°ì´í„° íƒ€ì…ì„ JSONê³¼ í˜¸í™˜ ë˜ëŠ” í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•´ì•¼ í•  ë•Œê°€ ìˆë‹¤  
ê·¸ëŸ¼ FastAPIì—ì„œ ì œê³µí•˜ëŠ” jsonable_encoder() í•¨ìˆ˜ë¥¼ ì¨ë¼

### Using the jsonable_encoder

DB(fake_db)ê°€ JSON í˜¸í™˜ ë°ì´í„°ë§Œ ì €ì¥ì´ ê°€ëŠ¥í•˜ë‹¤ê³  ê°€ì • í•  ë•Œ,  
jsonable_encoder()ë¥¼ ì‚¬ìš©í•´ì„œ ë³€í™˜ì„ ê±°ì¹˜ë©´  
Pydantic modelì„ dictë¡œ, datetimeì€ stríƒ€ì…ìœ¼ë¡œ  
DBì— ì €ì¥í•  ìˆ˜ ìˆëŠ” í˜•íƒœë¡œ ë³€í™˜í•´ì¤€ë‹¤

ì•„ë˜ ì˜ˆì‹œë¥¼ ë³´ì

```py
from datetime import datetime
from typing import Optional

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

fake_db = {}


class Item(BaseModel):
    title: str
    timestamp: datetime
    description: Optional[str] = None


app = FastAPI()


@app.put("/items/{id}")
def update_item(id: str, item: Item):
    json_compatible_item_data = jsonable_encoder(item)
    fake_db[id] = json_compatible_item_data
```

jsonable_encoder() í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì€ json.dumps()ë¡œ ì¸ì½”ë”©í•  ìˆ˜ ìˆëŠ” ê°’ì´ë‹¤  
ì´ëŠ” í•œì¤„ì˜ ê¸´ stringê°’ì´ ì•„ë‹Œ í•˜ìœ„ ê°’ë“¤ ëª¨ë‘ê°€ JSONê³¼ í˜¸í™˜ë˜ëŠ”  
dictì™€ ê°™ì€ íŒŒì´ì¬ì˜ ê¸°ë³¸ ë°ì´í„° êµ¬ì¡°ë‹¤


Note
- jsonable_encoder í•¨ìˆ˜ëŠ” ì‹¤ì œë¡œ FastAPI ë‚´ë¶€ì ìœ¼ë¡œ ë°ì´í„° ë³€í™˜ì— ì‚¬ìš©ëœë‹¤

---
---

## Body - Updates

### Update replacing with PUT

ì•„ì´í…œ ê¸°ì¡´ì˜ ì •ë³´ ì „ì²´ë¥¼ ëª¨ë‘ ìƒˆ ì •ë³´ë¡œ ì—…ë°ì´íŠ¸ í•  ë•ŒëŠ”  
HTTP PUT ë©”ì†Œë“œë¥¼ ì“°ë©´ ëœë‹¤

```py
@app.put("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    update_item_encoded = jsonable_encoder(item)
    items[item_id] = update_item_encoded
    return update_item_encoded
```

#### Warning about replacing

ê¸°ë³¸ê°’ì´ ìˆëŠ” ëª¨ë¸ì„ ì‚¬ìš©í•´ ì—…ë°ì´íŠ¸ë¥¼ ì§„í–‰ í•  ê²½ìš°,  
ê¸°ë³¸ê°’ì´ ìˆëŠ” í•„ë“œë¥¼ ê¸°ì¬í•˜ì§€ ì•Šìœ¼ë©´  
í•´ë‹¹ ê¸°ë³¸ê°’ìœ¼ë¡œ í•„ë“œê°€ ì—…ë°ì´íŠ¸ ë˜ì–´ë²„ë¦°ë‹¤  

### Partial updates with PATCH

ëª¨ë¸ ì „ì²´ë¥¼ ì—…ë°ì´íŠ¸ í•  ë•ŒëŠ” PUTì„ ì‚¬ìš©í•˜ì§€ë§Œ,  
ëª¨ë¸ì˜ ì¼ë¶€ í•„ë“œë§Œ ì—…ë°ì´íŠ¸ í•  ë•Œì—ëŠ” PATCH ì‚¬ìš©ì´ ê¶Œì¥ëœë‹¤  

Note
- PATCHëŠ” PUTë³´ë‹¤ ëœ ì•Œë ¤ì ¸ìˆê³   
  ë§ì€ íŒ€ë“¤ì´ ì¼ë¶€ë§Œ ì—…ë°ì´íŠ¸ í•  ë•Œì—ë„ PUTì„ ì‚¬ìš©í•œë‹¤  
  FastAPIëŠ” ì´ì— ëŒ€í•´ ê°•ì œí•˜ëŠ” ë¶€ë¶„ì´ ì—†ìœ¼ë¯€ë¡œ í•˜ê³  ì‹¶ì€ëŒ€ë¡œ í•´ë„ ëœë‹¤  
  ì´ ê°€ì´ë“œì—ì„œëŠ” ê° ê¸°ëŠ¥ë“¤ì´ ë§Œë“¤ì–´ì§„ ì›ë˜ì˜ ì˜ë„ì— ëŒ€í•´ ì„¤ëª…í•˜ê² ë‹¤

#### Using Pydantic's exclude_unset parameter

ë¶€ë¶„ ì—…ë°ì´íŠ¸ ê°’ì„ ë°›ì„ ë•ŒëŠ”  
Pydantic ëª¨ë¸ .dict() í•¨ìˆ˜ì˜ exclude_unset ì˜µì…˜ì´ ìœ ìš©í•˜ë‹¤  
- ì˜ˆì‹œ -> item.dict(exclude_unset=True)

ë°˜í™˜ê°’ì€ ê¸°ë³¸ê°’ë“¤ì„ ì œì™¸í•œ, ëª¨ë¸ì´ ìƒì„±ë  ë•Œ  
ì„¸íŒ…ëœ(requestë¡œ ë³´ë‚´ì§„) ê°’ë“¤ë§Œ dict íƒ€ì…ìœ¼ë¡œ ë°˜í™˜í•œë‹¤  

```py
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```

#### Using Pydantic's update parameter

ê¸°ì¡´ ëª¨ë¸ì— .copy() í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë³µì‚¬ë³¸ì´ ìƒì„± ê°€ëŠ¥í•˜ê³   
.copy() í•¨ìˆ˜ì˜ update ì˜µì…˜ì— ì—…ë°ì´íŠ¸ í•  ê°’ë“¤ì„  
dict íƒ€ì…ìœ¼ë¡œ ë„£ì–´ì£¼ë©´ ì—…ë°ì´íŠ¸ê°€ ê°€ëŠ¥í•˜ë‹¤
- ì˜ˆì‹œ -> stored_item_model.copy(update=update_data):

### Partial updates recap

ìš”ì•½ ì˜ˆì‹œ

```py
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```

Note
- Pydantic ëª¨ë¸ì„ ì…ë ¥ ë°›ì„ ë•ŒëŠ” ìœ íš¨ì„± ê²€ì¦ì´ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—  
  ë¶€ë¶„ ì—…ë°ì´íŠ¸ë¥¼ í•˜ë ¤ë©´ ëª¨ë¸ì˜ í•„ë“œë“¤ì— ëŒ€í•´  
  ê¸°ë³¸ê°’ ë˜ëŠ” ì˜µì…”ë„ ì„¤ì •ì´ í•„ìš”í•˜ë‹¤

---
---

## Dependencies - First Steps
FastAPIëŠ” ê°•ë ¥í•˜ë©´ì„œë„ ì§ê´€ì ì¸ ì˜ì¡´ì„± ì£¼ì… ì‹œìŠ¤í…œì„ ê°€ì§€ê³  ìˆê³   
ì‚¬ìš©í•˜ê¸° ì•„ì£¼ ì‰½ê²Œ ì„¤ê³„ë˜ì—ˆë‹¤  

### What is "Dependency Injection"
í”„ë¡œê·¸ë˜ë°ì—ì„œ ì˜ì¡´ì„± ì£¼ì…ì´ë€,  
- ì˜ì¡´ì„±: ì½”ë“œë¥¼ ì‚¬ìš©í•˜ê³  ì‘ë™í•˜ëŠ”ë°ì— í•„ìš”í•œ ê²ƒë“¤ì„ ì½”ë“œ ì™¸ë¶€ì— ì˜ì¡´í•˜ëŠ” ì„±ì§ˆ
- ì£¼ì…: ì‹œìŠ¤í…œ(ex. FastAPI)ì´ ì½”ë“œì— í•„ìš”í•œ ì˜ì¡´ì„±ë“¤ì„ ê´€ë¦¬(ì£¼ì…)í•´ì£¼ëŠ” ê²ƒ

ìœ ìš©í•œ ìƒí™©
- ê°™ì€ ë¡œì§ì´ ì—¬ëŸ¬ë²ˆ ì‚¬ìš©ë˜ëŠ” ê²½ìš°
- DB ì—°ê²°ì´ ê³µìœ ë˜ëŠ” ê²½ìš°
- ë³´ì•ˆ ê°•í™”, ì¸ì¦, ì—­í•  ìš”êµ¬ ì‚¬í•­ ë“±
- ê·¸ ì™¸ ë§ì´
- ìœ„ ëª¨ë“  ìƒí™©ì—ì„œ ì½”ë“œë¥¼ ìµœì†Œí™” í•  ë•Œ

### First Steps

ì•„ë˜ ì˜ˆì‹œë“¤ì´ ì§€ê¸ˆ ë‹¹ì¥ì€ ë³„ë¡œ ìœ ìš©í•´ë³´ì´ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ,  
ì˜ì¡´ì„± ì£¼ì…ì— ëŒ€í•´ ì´í•´í•˜ëŠ”ë° ë„ì›€ì´ ë  ê²ƒ

### Create a dependency, or "dependable"

ì˜ì¡´ì„±ì— ëŒ€í•´ ì‚´í´ë³´ì  

ì•„ë˜ ì½”ë“œëŠ” path operation í•¨ìˆ˜ì™€ ê°™ì€ íŒŒë¼ë¯¸í„°ë¥¼ ë°›ëŠ” í•¨ìˆ˜ë‹¤  

```py
from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

2ì¤„ë¡œ ëë‚œë‹¤  
ê·¸ë¦¬ê³  path operation í•¨ìˆ˜ì™€ ê°™ì€ ëª¨ì–‘ê³¼ êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆë‹¤  

ë§ˆì¹˜ "decorator"(@app.get("/some-path"))ê°€ ì—†ëŠ”  
path operation í•¨ìˆ˜ë¼ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤  

ê·¸ë¦¬ê³  ë­ë“ ì§€ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤  

### Import Depends

```py
from fastapi import Depends
```

### Declare the dependency, in the "dependant"

path operation í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ë¡œ Body, Query ë“±ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì²˜ëŸ¼  
Dependsë¥¼ ìƒˆ íŒŒë¼ë¯¸í„°ì™€ ê°™ì´ ì“°ë©´ ëœë‹¤  

```py
from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

ê·¸ëŸ¬ë‚˜ ì‘ë™ë°©ì‹ì´ Body, Query ë“±ê³¼ëŠ” ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤  

Dependsì—ëŠ” ë‹¨ì¼ ë§¤ê°œë³€ìˆ˜ë§Œ ì œê³µí•´ì•¼í•œë‹¤  
ì´ ë§¤ê°œë³€ìˆ˜ëŠ” í•¨ìˆ˜ì™€ ê°™ì•„ì•¼ í•˜ê³   
ê·¸ í•¨ìˆ˜ëŠ” path operation í•¨ìˆ˜ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ëŠ”ë‹¤

Tip
- ë‹¤ìŒ ì¥ì—ì„œ í•¨ìˆ˜ ì™¸ì— ì–´ë–¤ ê²ƒë“¤ì´ ì˜ì¡´ì„±ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆëŠ”ì§€ ë‚˜ì˜´

ì–¸ì œ ìš”ì²­ì„ ë°›ë˜, FastAPIëŠ” ì•„ë˜ì™€ ê°™ì´ ìˆ˜í–‰í•œë‹¤
- ì˜¬ë°”ë¥¸ ë§¤ê°œë³€ìˆ˜ì˜ ì˜ì¡´ì„±("dependable") í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤
- í•¨ìˆ˜ì—ì„œ ë°˜í™˜ê°’ì„ ê°€ì ¸ì˜¨ë‹¤
- ê·¸ ê²°ê³¼ë¥¼ path operation í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹í•œë‹¤

Check
- ì–´ë–¤ íŠ¹ë³„í•œ í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•´ì„œ ì „ë‹¬í•˜ê¸°ìœ„í•´  
  FastAPI ì–´ë”˜ê°€ì— ê·¸ ì–´ë–¤ê²ƒë„ "ë“±ë¡" ë¹„ìŠ·í•œ ê²ƒì¡°ì°¨ í•  í•„ìš”ì—†ë‹¤  
  ê·¸ëƒ¥ Dependsë§Œ ë˜ì ¸ì£¼ë©´ FastAPIê°€ ë‹¤ ì•Œì•„ì„œ í•œë‹¤

### To async or not to async

FastAPIì—ì„œ ì˜ì¡´ì„±ì€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í˜¸ì¶œë˜ë¯€ë¡œ  
ì„ ì–¸ì‹œ async def ë˜ëŠ” ì¼ë°˜ def ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤  

ê·¸ë¦¬ê³  ì¼ë°˜ def ì•ˆì— async defë¥¼ ì„ ì–¸í•˜ê±°ë‚˜  
async def ì•ˆì— ì¼ë°˜ defë¥¼ ì„ ì–¸í•´ë„ ìƒê´€ì—†ë‹¤  
FastAPIê°€ ì•Œì•„ì„œ ë‹¤ í•´ì¤€ë‹¤

### Integrated with OpenAPI
ì˜ì¡´ì„±ì˜ ëª¨ë“  ìš”ì²­ ì„ ì–¸, ìœ íš¨ì„± ê²€ì‚¬ ë° ìš”êµ¬ ì‚¬í•­ì€ ë™ì¼í•œ OpenAPI ìŠ¤í‚¤ë§ˆì— í†µí•©ë©ë‹ˆë‹¤
All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:



# Simple usage
If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, FastAPI).

With the Dependency Injection system, you can also tell FastAPI that your path operation function also "depends" on something else that should be executed before your path operation function, and FastAPI will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

resources
providers
services
injectables
components
# FastAPI plug-ins
Integrations and "plug-in"s can be built using the Dependency Injection system. But in fact, there is actually no need to create "plug-ins", as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions.

And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.

# FastAPI compatibility
The simplicity of the dependency injection system makes FastAPI compatible with:

all the relational databases
NoSQL databases
external packages
external APIs
authentication and authorization systems
API usage monitoring systems
response data injection systems
etc.
# Simple and Powerful
Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (path operations):

/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
then you could add different permission requirements for each of them just with dependencies and sub-dependencies:

current_user
active_user
admin_user
paying_user
/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
# Integrated with OpenAPI
All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations.

FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.

---
---

# Classes as Dependencies
Before diving deeper into the Dependency Injection system, let's upgrade the previous example.

# A dict from the previous example
In the previous example, we were returning a dict from our dependency ("dependable"):


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
But then we get a dict in the parameter commons of the path operation function.

And we know that editors can't provide a lot of support (like completion) for dicts, because they can't know their keys and value types.

We can do better...

# What makes a dependency
Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "callable" in Python is anything that Python can "call" like a function.

So, if you have an object something (that might not be a function) and you can "call" it (execute it) like:


something()
or


something(some_argument, some_keyword_argument="foo")
then it is a "callable".

# Classes as dependencies
You might notice that to create an instance of a Python class, you use that same syntax.

For example:


class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")
In this case, fluffy is an instance of the class Cat.

And to create fluffy, you are "calling" Cat.

So, a Python class is also a callable.

Then, in FastAPI, you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in FastAPI, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a path operation function. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters.

Then, we can change the dependency "dependable" common_parameters from above to the class CommonQueryParams:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
Pay attention to the __init__ method used to create the instance of the class:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
...it has the same parameters as our previous common_parameters:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
Those parameters are what FastAPI will use to "solve" the dependency.

In both cases, it will have:

an optional q query parameter.
a skip query parameter, with a default of 0.
a limit query parameter, with a default of 100.
In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.

# Use it
Now you can declare your dependency using this class.


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
FastAPI calls the CommonQueryParams class. This creates an "instance" of that class and the instance will be passed as the parameter commons to your function.

# Type annotation vs Depends
Notice how we write CommonQueryParams twice in the above code:


commons: CommonQueryParams = Depends(CommonQueryParams)
The last CommonQueryParams, in:


... = Depends(CommonQueryParams)
...is what FastAPI will actually use to know what is the dependency.

From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

In this case, the first CommonQueryParams, in:


commons: CommonQueryParams ...
...doesn't have any special meaning for FastAPI. FastAPI won't use it for data conversion, validation, etc. (as it is using the = Depends(CommonQueryParams) for that).

You could actually write just:


commons = Depends(CommonQueryParams)
..as in:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons=Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons, and then it can help you with code completion, type checks, etc:



# Shortcut
But you see that we are having some code repetition here, writing CommonQueryParams twice:


commons: CommonQueryParams = Depends(CommonQueryParams)
FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:


commons: CommonQueryParams = Depends(CommonQueryParams)
...you write:


commons: CommonQueryParams = Depends()
You declare the dependency as the type of the parameter, and you use Depends() as its "default" value (that after the =) for that function's parameter, without any parameter in Depends(), instead of having to write the full class again inside of Depends(CommonQueryParams).

The same example would then look like:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
...and FastAPI will know what to do.

Tip

If that seems more confusing than helpful, disregard it, you don't need it.

It is just a shortcut. Because FastAPI cares about helping you minimize code repetition.

---
---

# Sub-dependencies
You can create dependencies that have sub-dependencies.

They can be as deep as you need them to be.

FastAPI will take care of solving them.

# First dependency "dependable"
You could create a first dependency ("dependable") like:


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
It declares an optional query parameter q as a str, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.

# Second dependency, "dependable" and "dependant"
Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
Let's focus on the parameters declared:

Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
It depends on the query_extractor, and assigns the value returned by it to the parameter q.
It also declares an optional last_query cookie, as a str.
If the user didn't provide any query q, we use the last query used, which we saved to a cookie before.
# Use the dependency
Then we can use the dependency with:


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
Info

Notice that we are only declaring one dependency in the path operation function, the query_or_cookie_extractor.

But FastAPI will know that it has to solve query_extractor first, to pass the results of that to query_or_cookie_extractor while calling it.

Syntax error in graph
mermaid version 8.8.4
# Using the same dependency multiple times
If one of your dependencies is declared multiple times for the same path operation, for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request.

And it will save the returned value in a "cache" and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter use_cache=False when using Depends:


async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
    return {"fresh_value": fresh_value}
# Recap
Apart from all the fancy words used here, the Dependency Injection system is quite simple.

Just functions that look the same as the path operation functions.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

Tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about security.

And you will also see the amounts of code it will save you.

---
---

# Dependencies in path operation decorators
In some cases you don't really need the return value of a dependency inside your path operation function.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a path operation function parameter with Depends, you can add a list of dependencies to the path operation decorator.

# Add dependencies to the path operation decorator
The path operation decorator receives an optional argument dependencies.

It should be a list of Depends():


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
These dependencies will be executed/solved the same way normal dependencies. But their value (if they return any) won't be passed to your path operation function.

Tip

Some editors check for unused function parameters, and show them as errors.

Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

Info

In this example we use invented custom headers X-Key and X-Token.

But in real cases, when implementing security, you would get more benefits from using the integrated Security utilities (the next chapter).

# Dependencies errors and return values
You can use the same dependency functions you use normally.

# Dependency requirements
They can declare request requirements (like headers) or other sub-dependencies:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Raise exceptions
These dependencies can raise exceptions, the same as normal dependencies:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Return values
And they can return values or not, the values won't be used.

So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Dependencies for a group of path operations
Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.

# Global Dependencies
Next we will see how to add dependencies to the whole FastAPI application, so that they apply to each path operation.

---
---

# Global Dependencies
For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can add dependencies to the path operation decorators, you can add them to the FastAPI application.

In that case, they will be applied to all the path operations in the application:


from fastapi import Depends, FastAPI, Header, HTTPException


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])


@app.get("/items/")
async def read_items():
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]


@app.get("/users/")
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]
And all the ideas in the section about adding dependencies to the path operation decorators still apply, but in this case, to all of the path operations in the app.

# Dependencies for groups of path operations
Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.

---
---

# Dependencies with yield
FastAPI supports dependencies that do some extra steps after finishing.

To do this, use yield instead of return, and write the extra steps after.

Tip

Make sure to use yield one single time.

Info

For this to work, you need to use Python 3.7 or above, or in Python 3.6, install the "backports":


pip install async-exit-stack async-generator
This installs async-exit-stack and async-generator.

Technical Details

Any function that is valid to use with:

@contextlib.contextmanager or
@contextlib.asynccontextmanager
would be valid to use as a FastAPI dependency.

In fact, FastAPI uses those two decorators internally.

# A database dependency with yield
For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the yield statement is executed before sending a response:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
The yielded value is what is injected into path operations and other dependencies:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
The code following the yield statement is executed after the response has been delivered:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
Tip

You can use async or normal functions.

FastAPI will do the right thing with each, the same as with normal dependencies.

# A dependency with yield and try
If you use a try block in a dependency with yield, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a path operation, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with except SomeException.

In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not.


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
# Sub-dependencies with yield
You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use yield.

FastAPI will make sure that the "exit code" in each dependency with yield is run in the correct order.

For example, dependency_c can have a dependency on dependency_b, and dependency_b on dependency_a:


from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a=Depends(dependency_a)):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b=Depends(dependency_b)):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)
And all of them can use yield.

In this case dependency_c, to execute its exit code, needs the value from dependency_b (here named dep_b) to still be available.

And, in turn, dependency_b needs the value from dependency_a (here named dep_a) to be available for its exit code.


from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a=Depends(dependency_a)):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b=Depends(dependency_b)):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)
The same way, you could have dependencies with yield and return mixed.

And you could have a single dependency that requires several other dependencies with yield, etc.

You can have any combinations of dependencies that you want.

FastAPI will make sure everything is run in the correct order.

Technical Details

This works thanks to Python's Context Managers.

FastAPI uses them internally to achieve this.

# Dependencies with yield and HTTPException
You saw that you can use dependencies with yield and have try blocks that catch exceptions.

It might be tempting to raise an HTTPException or similar in the exit code, after the yield. But it won't work.

The exit code in dependencies with yield is executed after Exception Handlers. There's nothing catching exceptions thrown by your dependencies in the exit code (after the yield).

So, if you raise an HTTPException after the yield, the default (or any custom) exception handler that catches HTTPExceptions and returns an HTTP 400 response won't be there to catch that exception anymore.

This is what allows anything set in the dependency (e.g. a DB session) to, for example, be used by background tasks.

Background tasks are run after the response has been sent. So there's no way to raise an HTTPException because there's not even a way to change the response that is already sent.

But if a background task creates a DB error, at least you can rollback or cleanly close the session in the dependency with yield, and maybe log the error or report it to a remote tracking system.

If you have some code that you know could raise an exception, do the most normal/"Pythonic" thing and add a try block in that section of the code.

If you have custom exceptions that you would like to handle before returning the response and possibly modifying the response, maybe even raising an HTTPException, create a Custom Exception Handler.

Tip

You can still raise exceptions including HTTPException before the yield. But not after.

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.

Syntax error in graph
mermaid version 8.8.4
Info

Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation.

After one of those responses is sent, no other response can be sent.

Tip

This diagram shows HTTPException, but you could also raise any other exception for which you create a Custom Exception Handler. And that exception would be handled by that custom exception handler instead of the dependency exit code.

But if you raise an exception that is not handled by the exception handlers, it will be handled by the exit code of the dependency.

# Context Managers
# What are "Context Managers"
"Context Managers" are any of those Python objects that you can use in a with statement.

For example, you can use with to read a file:


with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)
Underneath, the open("./somefile.txt") creates an object that is a called a "Context Manager".

When the with block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with yield, FastAPI will internally convert it to a context manager, and combine it with some other related tools.

# Using context managers in dependencies with yield
Warning

This is, more or less, an "advanced" idea.

If you are just starting with FastAPI you might want to skip it for now.

In Python, you can create Context Managers by creating a class with two methods: __enter__() and __exit__().

You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function:


class MySuperContextManager:
    def __init__(self):
        self.db = DBSession()

    def __enter__(self):
        return self.db

    def __exit__(self, exc_type, exc_value, traceback):
        self.db.close()


async def get_db():
    with MySuperContextManager() as db:
        yield db
Tip

Another way to create a context manager is with:

@contextlib.contextmanager or
@contextlib.asynccontextmanager
using them to decorate a function with a single yield.

That's what FastAPI uses internally for dependencies with yield.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.

---
---
