---
header:
  teaser            : # 썸네일 이미지 /assets/images/face_army.jpg
title               : FastAPI \#4 # 제목
excerpt             : Python FastAPI Framework \#4 # 썸네일 한줄 요약
last_modified_at    : 2021-08-19 # 마지막 수정일
categories          : etc
tags                : FastAPI Python
toc                 : # 목차 사용여부
toc_label           : # 목차 제목
# {: .notice--info}
---

---
## 출처 : [FastAPI](https://fastapi.tiangolo.com/)

🚫 아래 내용은 주관적인 생각이므로 사실과 다를 수 있습니다.

---
---

## JSON Compatible Encoder

DB에 저장을 할 때처럼,  
어떤 데이터 타입을 JSON과 호환 되는 형식으로 변환해야 할 때가 있다  
그럼 FastAPI에서 제공하는 jsonable_encoder() 함수를 써라

### Using the jsonable_encoder

DB(fake_db)가 JSON 호환 데이터만 저장이 가능하다고 가정 할 때,  
jsonable_encoder()를 사용해서 변환을 거치면  
Pydantic model을 dict로, datetime은 str타입으로  
DB에 저장할 수 있는 형태로 변환해준다

아래 예시를 보자

```py
from datetime import datetime
from typing import Optional

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

fake_db = {}


class Item(BaseModel):
    title: str
    timestamp: datetime
    description: Optional[str] = None


app = FastAPI()


@app.put("/items/{id}")
def update_item(id: str, item: Item):
    json_compatible_item_data = jsonable_encoder(item)
    fake_db[id] = json_compatible_item_data
```

jsonable_encoder() 함수의 반환값은 json.dumps()로 인코딩할 수 있는 값이다  
이는 한줄의 긴 string값이 아닌 하위 값들 모두가 JSON과 호환되는  
dict와 같은 파이썬의 기본 데이터 구조다


Note
- jsonable_encoder 함수는 실제로 FastAPI 내부적으로 데이터 변환에 사용된다

---
---

## Body - Updates

### Update replacing with PUT

아이템 기존의 정보 전체를 모두 새 정보로 업데이트 할 때는  
HTTP PUT 메소드를 쓰면 된다

```py
@app.put("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    update_item_encoded = jsonable_encoder(item)
    items[item_id] = update_item_encoded
    return update_item_encoded
```

#### Warning about replacing

기본값이 있는 모델을 사용해 업데이트를 진행 할 경우,  
기본값이 있는 필드를 기재하지 않으면  
해당 기본값으로 필드가 업데이트 되어버린다  

### Partial updates with PATCH

모델 전체를 업데이트 할 때는 PUT을 사용하지만,  
모델의 일부 필드만 업데이트 할 때에는 PATCH 사용이 권장된다  

Note
- PATCH는 PUT보다 덜 알려져있고  
  많은 팀들이 일부만 업데이트 할 때에도 PUT을 사용한다  
  FastAPI는 이에 대해 강제하는 부분이 없으므로 하고 싶은대로 해도 된다  
  이 가이드에서는 각 기능들이 만들어진 원래의 의도에 대해 설명하겠다

#### Using Pydantic's exclude_unset parameter

부분 업데이트 값을 받을 때는  
Pydantic 모델 .dict() 함수의 exclude_unset 옵션이 유용하다  
- 예시 -> item.dict(exclude_unset=True)

반환값은 기본값들을 제외한, 모델이 생성될 때  
세팅된(request로 보내진) 값들만 dict 타입으로 반환한다  

```py
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```

#### Using Pydantic's update parameter

기존 모델에 .copy() 함수를 이용해 복사본이 생성 가능하고  
.copy() 함수의 update 옵션에 업데이트 할 값들을  
dict 타입으로 넣어주면 업데이트가 가능하다
- 예시 -> stored_item_model.copy(update=update_data):

### Partial updates recap

요약 예시

```py
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```

Note
- Pydantic 모델을 입력 받을 때는 유효성 검증이 실행되기 때문에  
  부분 업데이트를 하려면 모델의 필드들에 대해  
  기본값 또는 옵셔널 설정이 필요하다

---
---

## Dependencies - First Steps
FastAPI는 강력하면서도 직관적인 의존성 주입 시스템을 가지고 있고  
사용하기 아주 쉽게 설계되었다  

### What is "Dependency Injection"
프로그래밍에서 의존성 주입이란,  
- 의존성: 코드를 사용하고 작동하는데에 필요한 것들을 코드 외부에 의존하는 성질
- 주입: 시스템(ex. FastAPI)이 코드에 필요한 의존성들을 관리(주입)해주는 것

유용한 상황
- 같은 로직이 여러번 사용되는 경우
- DB 연결이 공유되는 경우
- 보안 강화, 인증, 역할 요구 사항 등
- 그 외 많이
- 위 모든 상황에서 코드를 최소화 할 때

### First Steps

아래 예시들이 지금 당장은 별로 유용해보이지 않을 수 있지만,  
의존성 주입에 대해 이해하는데 도움이 될 것

### Create a dependency, or "dependable"

의존성에 대해 살펴보자  

아래 코드는 path operation 함수와 같은 파라미터를 받는 함수다  

```py
from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

2줄로 끝난다  
그리고 path operation 함수와 같은 모양과 구조를 가지고 있다  

마치 "decorator"(@app.get("/some-path"))가 없는  
path operation 함수라고 생각할 수 있다  

그리고 뭐든지 반환할 수 있다  

### Import Depends

```py
from fastapi import Depends
```

### Declare the dependency, in the "dependant"

path operation 함수의 파라미터로 Body, Query 등을 사용하는 것처럼  
Depends를 새 파라미터와 같이 쓰면 된다  

```py
from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

그러나 작동방식이 Body, Query 등과는 조금 다르다  

Depends에는 단일 매개변수만 제공해야한다  
이 매개변수는 함수와 같아야 하고  
그 함수는 path operation 함수와 같은 방식으로 매개변수를 받는다

Tip
- 다음 장에서 함수 외에 어떤 것들이 의존성으로 사용될 수 있는지 나옴

언제 요청을 받던, FastAPI는 아래와 같이 수행한다
- 올바른 매개변수의 의존성("dependable") 함수를 호출한다
- 함수에서 반환값을 가져온다
- 그 결과를 path operation 함수의 매개변수에 할당한다

Check
- 어떤 특별한 클래스를 선언해서 전달하기위해  
  FastAPI 어딘가에 그 어떤것도 "등록" 비슷한 것조차 할 필요없다  
  그냥 Depends만 던져주면 FastAPI가 다 알아서 한다

### To async or not to async

FastAPI에서 의존성은 같은 방식으로 호출되므로  
선언시 async def 또는 일반 def 모두 사용 가능하다  

그리고 일반 def 안에 async def를 선언하거나  
async def 안에 일반 def를 선언해도 상관없다  
FastAPI가 알아서 다 해준다

### Integrated with OpenAPI
의존성의 모든 요청 선언, 유효성 검사 및 요구 사항은 동일한 OpenAPI 스키마에 통합됩니다
All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:



# Simple usage
If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, FastAPI).

With the Dependency Injection system, you can also tell FastAPI that your path operation function also "depends" on something else that should be executed before your path operation function, and FastAPI will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

resources
providers
services
injectables
components
# FastAPI plug-ins
Integrations and "plug-in"s can be built using the Dependency Injection system. But in fact, there is actually no need to create "plug-ins", as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions.

And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.

# FastAPI compatibility
The simplicity of the dependency injection system makes FastAPI compatible with:

all the relational databases
NoSQL databases
external packages
external APIs
authentication and authorization systems
API usage monitoring systems
response data injection systems
etc.
# Simple and Powerful
Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (path operations):

/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
then you could add different permission requirements for each of them just with dependencies and sub-dependencies:

current_user
active_user
admin_user
paying_user
/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
# Integrated with OpenAPI
All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations.

FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.

---
---

# Classes as Dependencies
Before diving deeper into the Dependency Injection system, let's upgrade the previous example.

# A dict from the previous example
In the previous example, we were returning a dict from our dependency ("dependable"):


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
But then we get a dict in the parameter commons of the path operation function.

And we know that editors can't provide a lot of support (like completion) for dicts, because they can't know their keys and value types.

We can do better...

# What makes a dependency
Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "callable" in Python is anything that Python can "call" like a function.

So, if you have an object something (that might not be a function) and you can "call" it (execute it) like:


something()
or


something(some_argument, some_keyword_argument="foo")
then it is a "callable".

# Classes as dependencies
You might notice that to create an instance of a Python class, you use that same syntax.

For example:


class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")
In this case, fluffy is an instance of the class Cat.

And to create fluffy, you are "calling" Cat.

So, a Python class is also a callable.

Then, in FastAPI, you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in FastAPI, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a path operation function. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters.

Then, we can change the dependency "dependable" common_parameters from above to the class CommonQueryParams:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
Pay attention to the __init__ method used to create the instance of the class:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
...it has the same parameters as our previous common_parameters:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons


@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
Those parameters are what FastAPI will use to "solve" the dependency.

In both cases, it will have:

an optional q query parameter.
a skip query parameter, with a default of 0.
a limit query parameter, with a default of 100.
In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.

# Use it
Now you can declare your dependency using this class.


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
FastAPI calls the CommonQueryParams class. This creates an "instance" of that class and the instance will be passed as the parameter commons to your function.

# Type annotation vs Depends
Notice how we write CommonQueryParams twice in the above code:


commons: CommonQueryParams = Depends(CommonQueryParams)
The last CommonQueryParams, in:


... = Depends(CommonQueryParams)
...is what FastAPI will actually use to know what is the dependency.

From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

In this case, the first CommonQueryParams, in:


commons: CommonQueryParams ...
...doesn't have any special meaning for FastAPI. FastAPI won't use it for data conversion, validation, etc. (as it is using the = Depends(CommonQueryParams) for that).

You could actually write just:


commons = Depends(CommonQueryParams)
..as in:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons=Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons, and then it can help you with code completion, type checks, etc:



# Shortcut
But you see that we are having some code repetition here, writing CommonQueryParams twice:


commons: CommonQueryParams = Depends(CommonQueryParams)
FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:


commons: CommonQueryParams = Depends(CommonQueryParams)
...you write:


commons: CommonQueryParams = Depends()
You declare the dependency as the type of the parameter, and you use Depends() as its "default" value (that after the =) for that function's parameter, without any parameter in Depends(), instead of having to write the full class again inside of Depends(CommonQueryParams).

The same example would then look like:


from typing import Optional

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response
...and FastAPI will know what to do.

Tip

If that seems more confusing than helpful, disregard it, you don't need it.

It is just a shortcut. Because FastAPI cares about helping you minimize code repetition.

---
---

# Sub-dependencies
You can create dependencies that have sub-dependencies.

They can be as deep as you need them to be.

FastAPI will take care of solving them.

# First dependency "dependable"
You could create a first dependency ("dependable") like:


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
It declares an optional query parameter q as a str, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.

# Second dependency, "dependable" and "dependant"
Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
Let's focus on the parameters declared:

Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
It depends on the query_extractor, and assigns the value returned by it to the parameter q.
It also declares an optional last_query cookie, as a str.
If the user didn't provide any query q, we use the last query used, which we saved to a cookie before.
# Use the dependency
Then we can use the dependency with:


from typing import Optional

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: Optional[str] = None):
    return q


def query_or_cookie_extractor(
    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):
    return {"q_or_cookie": query_or_default}
Info

Notice that we are only declaring one dependency in the path operation function, the query_or_cookie_extractor.

But FastAPI will know that it has to solve query_extractor first, to pass the results of that to query_or_cookie_extractor while calling it.

Syntax error in graph
mermaid version 8.8.4
# Using the same dependency multiple times
If one of your dependencies is declared multiple times for the same path operation, for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request.

And it will save the returned value in a "cache" and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter use_cache=False when using Depends:


async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
    return {"fresh_value": fresh_value}
# Recap
Apart from all the fancy words used here, the Dependency Injection system is quite simple.

Just functions that look the same as the path operation functions.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

Tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about security.

And you will also see the amounts of code it will save you.

---
---

# Dependencies in path operation decorators
In some cases you don't really need the return value of a dependency inside your path operation function.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a path operation function parameter with Depends, you can add a list of dependencies to the path operation decorator.

# Add dependencies to the path operation decorator
The path operation decorator receives an optional argument dependencies.

It should be a list of Depends():


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
These dependencies will be executed/solved the same way normal dependencies. But their value (if they return any) won't be passed to your path operation function.

Tip

Some editors check for unused function parameters, and show them as errors.

Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

Info

In this example we use invented custom headers X-Key and X-Token.

But in real cases, when implementing security, you would get more benefits from using the integrated Security utilities (the next chapter).

# Dependencies errors and return values
You can use the same dependency functions you use normally.

# Dependency requirements
They can declare request requirements (like headers) or other sub-dependencies:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Raise exceptions
These dependencies can raise exceptions, the same as normal dependencies:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Return values
And they can return values or not, the values won't be used.

So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:


from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
# Dependencies for a group of path operations
Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.

# Global Dependencies
Next we will see how to add dependencies to the whole FastAPI application, so that they apply to each path operation.

---
---

# Global Dependencies
For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can add dependencies to the path operation decorators, you can add them to the FastAPI application.

In that case, they will be applied to all the path operations in the application:


from fastapi import Depends, FastAPI, Header, HTTPException


async def verify_token(x_token: str = Header(...)):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: str = Header(...)):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])


@app.get("/items/")
async def read_items():
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]


@app.get("/users/")
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]
And all the ideas in the section about adding dependencies to the path operation decorators still apply, but in this case, to all of the path operations in the app.

# Dependencies for groups of path operations
Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.

---
---

# Dependencies with yield
FastAPI supports dependencies that do some extra steps after finishing.

To do this, use yield instead of return, and write the extra steps after.

Tip

Make sure to use yield one single time.

Info

For this to work, you need to use Python 3.7 or above, or in Python 3.6, install the "backports":


pip install async-exit-stack async-generator
This installs async-exit-stack and async-generator.

Technical Details

Any function that is valid to use with:

@contextlib.contextmanager or
@contextlib.asynccontextmanager
would be valid to use as a FastAPI dependency.

In fact, FastAPI uses those two decorators internally.

# A database dependency with yield
For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the yield statement is executed before sending a response:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
The yielded value is what is injected into path operations and other dependencies:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
The code following the yield statement is executed after the response has been delivered:


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
Tip

You can use async or normal functions.

FastAPI will do the right thing with each, the same as with normal dependencies.

# A dependency with yield and try
If you use a try block in a dependency with yield, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a path operation, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with except SomeException.

In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not.


async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()
# Sub-dependencies with yield
You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use yield.

FastAPI will make sure that the "exit code" in each dependency with yield is run in the correct order.

For example, dependency_c can have a dependency on dependency_b, and dependency_b on dependency_a:


from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a=Depends(dependency_a)):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b=Depends(dependency_b)):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)
And all of them can use yield.

In this case dependency_c, to execute its exit code, needs the value from dependency_b (here named dep_b) to still be available.

And, in turn, dependency_b needs the value from dependency_a (here named dep_a) to be available for its exit code.


from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a=Depends(dependency_a)):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b=Depends(dependency_b)):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)
The same way, you could have dependencies with yield and return mixed.

And you could have a single dependency that requires several other dependencies with yield, etc.

You can have any combinations of dependencies that you want.

FastAPI will make sure everything is run in the correct order.

Technical Details

This works thanks to Python's Context Managers.

FastAPI uses them internally to achieve this.

# Dependencies with yield and HTTPException
You saw that you can use dependencies with yield and have try blocks that catch exceptions.

It might be tempting to raise an HTTPException or similar in the exit code, after the yield. But it won't work.

The exit code in dependencies with yield is executed after Exception Handlers. There's nothing catching exceptions thrown by your dependencies in the exit code (after the yield).

So, if you raise an HTTPException after the yield, the default (or any custom) exception handler that catches HTTPExceptions and returns an HTTP 400 response won't be there to catch that exception anymore.

This is what allows anything set in the dependency (e.g. a DB session) to, for example, be used by background tasks.

Background tasks are run after the response has been sent. So there's no way to raise an HTTPException because there's not even a way to change the response that is already sent.

But if a background task creates a DB error, at least you can rollback or cleanly close the session in the dependency with yield, and maybe log the error or report it to a remote tracking system.

If you have some code that you know could raise an exception, do the most normal/"Pythonic" thing and add a try block in that section of the code.

If you have custom exceptions that you would like to handle before returning the response and possibly modifying the response, maybe even raising an HTTPException, create a Custom Exception Handler.

Tip

You can still raise exceptions including HTTPException before the yield. But not after.

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.

Syntax error in graph
mermaid version 8.8.4
Info

Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation.

After one of those responses is sent, no other response can be sent.

Tip

This diagram shows HTTPException, but you could also raise any other exception for which you create a Custom Exception Handler. And that exception would be handled by that custom exception handler instead of the dependency exit code.

But if you raise an exception that is not handled by the exception handlers, it will be handled by the exit code of the dependency.

# Context Managers
# What are "Context Managers"
"Context Managers" are any of those Python objects that you can use in a with statement.

For example, you can use with to read a file:


with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)
Underneath, the open("./somefile.txt") creates an object that is a called a "Context Manager".

When the with block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with yield, FastAPI will internally convert it to a context manager, and combine it with some other related tools.

# Using context managers in dependencies with yield
Warning

This is, more or less, an "advanced" idea.

If you are just starting with FastAPI you might want to skip it for now.

In Python, you can create Context Managers by creating a class with two methods: __enter__() and __exit__().

You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function:


class MySuperContextManager:
    def __init__(self):
        self.db = DBSession()

    def __enter__(self):
        return self.db

    def __exit__(self, exc_type, exc_value, traceback):
        self.db.close()


async def get_db():
    with MySuperContextManager() as db:
        yield db
Tip

Another way to create a context manager is with:

@contextlib.contextmanager or
@contextlib.asynccontextmanager
using them to decorate a function with a single yield.

That's what FastAPI uses internally for dependencies with yield.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.

---
---
